--------------------------------------------------------------------------------
--
-- This VHDL file was generated by EASE/HDL 8.0 Revision 10 from HDL Works B.V.
--
-- Ease library  : work
-- HDL library   : work
-- Host name     : SERING
-- User name     : peterj
-- Time stamp    : Tue Oct 13 13:08:56 2015
--
-- Designed by   : 
-- Company       : 
-- Project info  : 
--
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Object        : Entity work.pullup1
-- Last modified : Tue Sep 15 12:45:39 2015.
--------------------------------------------------------------------------------



library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity pullup1 is
  port (
    o1 : out    std_logic;
    o2 : out    std_logic);
end entity pullup1;

--------------------------------------------------------------------------------
-- Object        : Architecture work.pullup1.structure
-- Last modified : Tue Sep 15 12:45:39 2015.
--------------------------------------------------------------------------------


architecture structure of pullup1 is

begin
   o1 <= 'H';
   o2 <= 'H';
end architecture structure ; -- of pullup1

--------------------------------------------------------------------------------
-- Object        : Entity work.wr_core
-- Last modified : Mon Sep 28 15:53:29 2015.
--------------------------------------------------------------------------------



library ieee, work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.wrcore_pkg.all;
use work.genram_pkg.all;
use work.wishbone_pkg.all;
use work.endpoint_pkg.all;
use work.wr_fabric_pkg.all;
use work.sysc_wbgen2_pkg.all;
use work.softpll_pkg.all;

entity wr_core is
  generic(
    g_with_external_clock_input : boolean := false;
    g_aux_clks                  : integer := 1;
    g_pcs_16bit                 : boolean := false;
    g_rx_buffer_size            : integer := 1024;
    g_dpram_size                : integer := 90112/4;  --in 32-bit words;
    g_phys_uart                 : boolean := true;
    g_virtual_uart              : boolean := false;
    g_interface_mode            : t_wishbone_interface_mode := PIPELINED;
    g_address_granularity       : t_wishbone_address_granularity := WORD;
    g_simulation                : integer := 0;
    g_aux_sdb                   : t_sdb_device := c_wrc_periph3_sdb;
    g_softpll_enable_debugger   : boolean := false;
    g_tx_runt_padding           : boolean := false;
    g_vuart_fifo_size           : integer := 1024;
    g_dpram_initf               : string := "default";
    g_ref_clock_rate            : integer := 125000000;
    g_ext_clock_rate            : integer := 10000000);
  port (
    aux_master_i         : in     t_wishbone_master_in;
    aux_master_o         : out    t_wishbone_master_out;
    btn1_i               : in     std_logic := '1';
    btn2_i               : in     std_logic := '1';
    clk_aux_i            : in     std_logic_vector(g_aux_clks-1 downto 0) := (others => '0');
    clk_dmtd_i           : in     std_logic;
    clk_ext_i            : in     std_logic := '0';
    clk_ext_mul_i        : in     std_logic := '0';
    clk_ext_mul_locked_i : in     std_logic := '1';
    clk_ref_i            : in     std_logic;
    clk_sys_i            : in     std_logic;
    dac_dpll_data_o      : out    std_logic_vector(15 downto 0);
    dac_dpll_load_p1_o   : out    std_logic;
    dac_hpll_data_o      : out    std_logic_vector(15 downto 0);
    dac_hpll_load_p1_o   : out    std_logic;
    dio_o                : out    std_logic_vector(3 downto 0);
    ext_snk_i            : in     t_wrf_sink_in;
    ext_snk_o            : out    t_wrf_sink_out;
    ext_src_i            : in     t_wrf_source_in;
    ext_src_o            : out    t_wrf_source_out;
    fc_tx_pause_delay_i  : in     std_logic_vector(15 downto 0) := x"0000";
    fc_tx_pause_ready_o  : out    std_logic;
    fc_tx_pause_req_i    : in     std_logic := '0';
    led_act_o            : out    std_logic;
    led_link_o           : out    std_logic;
    link_ok_o            : out    std_logic;
    owr_en_o             : out    std_logic_vector(1 downto 0);
    owr_i                : in     std_logic_vector(1 downto 0) := (others => '1');
    owr_pwren_o          : out    std_logic_vector(1 downto 0);
    phy_loopen_o         : out    std_logic;
    phy_loopen_vec_o     : out    std_logic_vector(2 downto 0);
    phy_rdy_i            : in     std_logic := '1';
    phy_ref_clk_i        : in     std_logic;
    phy_rst_o            : out    std_logic;
    phy_rx_bitslide_i    : in     std_logic_vector(f_pcs_bts_width(g_pcs_16bit)-1 downto 0);
    phy_rx_data_i        : in     std_logic_vector(f_pcs_data_width(g_pcs_16bit)-1 downto 0);
    phy_rx_enc_err_i     : in     std_logic;
    phy_rx_k_i           : in     std_logic_vector(f_pcs_k_width(g_pcs_16bit)-1 downto 0) := (others=>'0');
    phy_rx_rbclk_i       : in     std_logic;
    phy_sfp_los_i        : in     std_logic := '0';
    phy_sfp_tx_disable_o : out    std_logic;
    phy_sfp_tx_fault_i   : in     std_logic := '0';
    phy_tx_data_o        : out    std_logic_vector(f_pcs_data_width(g_pcs_16bit)-1 downto 0);
    phy_tx_disparity_i   : in     std_logic;
    phy_tx_enc_err_i     : in     std_logic;
    phy_tx_k_o           : out    std_logic_vector(f_pcs_k_width(g_pcs_16bit)-1 downto 0);
    phy_tx_prbs_sel_o    : out    std_logic_vector(2 downto 0);
    pps_ext_i            : in     std_logic := '0';
    pps_led_o            : out    std_logic;
    pps_o                : out    std_logic;
    rst_aux_n_o          : out    std_logic;
    rst_n_i              : in     std_logic;
    rxts_o               : out    std_logic;
    scl_i                : in     std_logic := '1';
    scl_o                : out    std_logic;
    sda_i                : in     std_logic := '1';
    sda_o                : out    std_logic;
    sfp_det_i            : in     std_logic := '1';
    sfp_scl_i            : in     std_logic := '1';
    sfp_scl_o            : out    std_logic;
    sfp_sda_i            : in     std_logic := '1';
    sfp_sda_o            : out    std_logic;
    spi_miso_i           : in     std_logic := '0';
    spi_mosi_o           : out    std_logic;
    spi_ncs_o            : out    std_logic;
    spi_sclk_o           : out    std_logic;
    tm_clk_aux_lock_en_i : in     std_logic_vector(g_aux_clks-1 downto 0) := (others => '0');
    tm_clk_aux_locked_o  : out    std_logic_vector(g_aux_clks-1 downto 0);
    tm_cycles_o          : out    std_logic_vector(27 downto 0);
    tm_dac_value_o       : out    std_logic_vector(23 downto 0);
    tm_dac_wr_o          : out    std_logic_vector(g_aux_clks-1 downto 0);
    tm_link_up_o         : out    std_logic;
    tm_tai_o             : out    std_logic_vector(39 downto 0);
    tm_time_valid_o      : out    std_logic;
    txts_o               : out    std_logic;
    txtsu_ack_i          : in     std_logic := '1';
    txtsu_frame_id_o     : out    std_logic_vector(15 downto 0);
    txtsu_port_id_o      : out    std_logic_vector(4 downto 0);
    txtsu_stb_o          : out    std_logic;
    txtsu_ts_incorrect_o : out    std_logic;
    txtsu_ts_value_o     : out    std_logic_vector(31 downto 0);
    uart_rxd_i           : in     std_logic := '1';
    uart_txd_o           : out    std_logic;
    wb_i                 : in     t_wishbone_slave_in;
    wb_o                 : out    t_wishbone_slave_out);
end entity wr_core;

--------------------------------------------------------------------------------
-- Object        : Architecture work.wr_core.struct
-- Last modified : Mon Sep 28 15:53:29 2015.
--------------------------------------------------------------------------------

architecture struct of wr_core is

    function f_int_to_bool(x : integer) return boolean is
    begin
      if(x /= 0) then
        return true;
      else
        return false;
      end if;
    end f_int_to_bool;

    function f_choose_lm32_firmware_file return string is
    begin
      if(g_dpram_initf = "default") then
        if(g_simulation /= 0) then
          report "[WR Core] Using simulation LM32 firmware." severity note;
          return "wrc-simulation.ram";
        else
          report "[WR Core] Using release LM32 firmware." severity note;
          return "wrc-release.ram";
        end if;
      else
        report "[WR Core] Using user-provided LM32 firmware." severity note;
        return g_dpram_initf;
      end if;
    end function;

    function f_check_if_lm32_firmware_necessary return boolean is
    begin
      if(g_dpram_initf /= "") then
        return true;
      else
        return false;
      end if;
    end function;

    -----------------------------------------------------------------------------
    --WB Secondary Crossbar
    -----------------------------------------------------------------------------
    constant c_secbar_layout : t_sdb_record_array(7 downto 0) :=
      (0 => f_sdb_embed_device(c_xwr_mini_nic_sdb,   x"00000000"),
       1 => f_sdb_embed_device(c_xwr_endpoint_sdb,   x"00000100"),
       2 => f_sdb_embed_device(c_xwr_softpll_ng_sdb, x"00000200"),
       3 => f_sdb_embed_device(c_xwr_pps_gen_sdb,    x"00000300"),
       4 => f_sdb_embed_device(c_wrc_periph0_sdb,    x"00000400"),  -- Syscon
       5 => f_sdb_embed_device(c_wrc_periph1_sdb,    x"00000500"),  -- UART
       6 => f_sdb_embed_device(c_wrc_periph2_sdb,    x"00000600"),  -- 1-Wire
       7 => f_sdb_embed_device(g_aux_sdb,            x"00000700")   -- aux WB bus
       );

    constant c_secbar_sdb_address : t_wishbone_address := x"00000800";
    constant c_secbar_bridge_sdb : t_sdb_bridge := 
       f_xwb_bridge_layout_sdb(true, c_secbar_layout, c_secbar_sdb_address);

    constant c_lm32_2nd_bridge_sdb : t_sdb_bridge := (
      sdb_child          => x"0000000000040000",
      sdb_component => (
      addr_first         => x"0000000000000000", -- map LM32_2nd memory space
      addr_last          => x"000000000004ffff",
      product => (
      vendor_id          => x"000000000000CE42", -- CERN
      device_id          => x"d1bbb357",
      version            => x"00000001",
      date               => x"20131119",
      name               => "LM32_2nd MEM SPACE "))
      );

    -----------------------------------------------------------------------------
    --WB intercon
    -----------------------------------------------------------------------------
    constant c_layout : t_sdb_record_array(1 downto 0) :=
     (0 => f_sdb_embed_device(f_xwb_dpram(g_dpram_size), x"00000000"),
      1 => f_sdb_embed_bridge(c_secbar_bridge_sdb,       x"00020000"));
    constant c_sdb_address : t_wishbone_address := x"00030000";

    constant c_mnic_memsize_log2 : integer := f_log2_size(g_dpram_size);

  signal rst_net_n             : std_logic;
  signal secbar_master_o       : t_wishbone_master_out_array(7 downto 0);
  signal secbar_master_i       : t_wishbone_master_in_array(7 downto 0);
  signal ep_wb_out             : t_wishbone_slave_out;
  signal ep_wb_in              : t_wishbone_slave_in;
  signal spll_wb_out           : t_wishbone_slave_out;
  signal rst_wrc_n             : std_logic;
  signal s_pps_csync           : std_logic;
  signal pps_valid             : std_logic;
  signal ep_src_out            : t_wrf_source_out;
  signal ep_src_in             : t_wrf_source_in;
  signal ep_snk_out            : t_wrf_sink_out;
  signal ep_snk_in             : t_wrf_sink_in;
  signal ep_txtsu_port_id      : std_logic_vector(4 downto 0);
  signal ep_txtsu_frame_id     : std_logic_vector(16 - 1 downto 0);
  signal ep_txtsu_ts_value     : std_logic_vector(28 + 4 - 1 downto 0);
  signal ep_txtsu_ts_incorrect : std_logic;
  signal cbar_master_i         : t_wishbone_master_in_array(1 downto 0);
  signal cbar_master_o         : t_wishbone_master_out_array(1 downto 0);
  signal cbar_slave_i          : t_wishbone_slave_in_array(2 downto 0);
  signal cbar_slave_o          : t_wishbone_slave_out_array(2 downto 0);
  signal dpram_wbb_o           : t_wishbone_slave_out;
  signal mnic_mem_data_o       : std_logic_vector(31 downto 0);
  signal mnic_mem_addr_o       : std_logic_vector(c_mnic_memsize_log2 -1 downto 0);
  signal mnic_mem_data_i       : std_logic_vector(31 downto 0);
  signal lm32_irq_slv          : std_logic_vector(31 downto 0);
  signal softpll_irq           : std_logic;
  signal dac_dpll_data         : std_logic_vector(15 downto 0);
  signal dac_dpll_sel          : std_logic_vector(3 downto 0);
  signal dac_dpll_load_p1      : std_logic;
  signal clk_fb                : std_logic_vector(g_aux_clks downto 0);
  signal out_enable            : std_logic_vector(g_aux_clks downto 0);
  signal spll_out_locked       : std_logic_vector(g_aux_clks downto 0);
  signal mnic_txtsu_ack        : std_logic;
  signal U_SOFTPLL_clk_ref_i   : std_logic_vector(0 downto 0);
  signal periph_slave_o        : t_wishbone_slave_out_array(0 to 2);
  signal periph_slave_i        : t_wishbone_slave_in_array(0 to 2);
  signal dpram_wbb_i           : t_wishbone_slave_in;
  signal slave1_o              : t_wishbone_slave_out;
  signal slave1_i              : t_wishbone_slave_in;
  signal dwb_o                 : t_wishbone_master_out;
  signal dwb_i                 : t_wishbone_master_in;
  signal iwb_o                 : t_wishbone_master_out;
  signal iwb_i                 : t_wishbone_master_in;
  signal minic_wb_out          : t_wishbone_slave_out;
  signal minic_wb_in           : t_wishbone_slave_in;
  signal spll_wb_in            : t_wishbone_slave_in;
  signal ppsg_wb_out           : t_wishbone_slave_out;
  signal ppsg_wb_in            : t_wishbone_slave_in;
  signal slave0_i              : t_wishbone_slave_in_array(0 downto 0);
  signal slave0_o              : t_wishbone_slave_out_array(0 downto 0);
  signal ep_txtsu_stb          : std_logic;
  signal ep_led_link           : std_logic;
  signal mux_snk_out           : t_wrf_sink_out_array(1 downto 0);
  signal mux_snk_in            : t_wrf_sink_in_array(1 downto 0);
  signal mux_src_out           : t_wrf_source_out_array(1 downto 0);
  signal mux_src_in            : t_wrf_source_in_array(1 downto 0);
  signal mux_class             : t_wrf_mux_class(1 downto 0);
  signal ep_txtsu_ack          : std_logic;
  signal mnic_mem_wr_o         : std_logic;
  signal mnic_txtsu_stb        : std_logic;

  component xwr_pps_gen
    generic(
      g_interface_mode       : t_wishbone_interface_mode := classic;
      g_address_granularity  : t_wishbone_address_granularity := word;
      g_ref_clock_rate       : integer := 125000000;
      g_ext_clock_rate       : integer := 10000000;
      g_with_ext_clock_input : boolean := false);
    port (
      clk_ref_i       : in     std_logic;
      clk_sys_i       : in     std_logic;
      clk_ext_i       : in     std_logic := '0';
      rst_n_i         : in     std_logic;
      slave_i         : in     t_wishbone_slave_in;
      slave_o         : out    t_wishbone_slave_out;
      pps_in_i        : in     std_logic;
      pps_csync_o     : out    std_logic;
      pps_out_o       : out    std_logic;
      pps_led_o       : out    std_logic;
      pps_valid_o     : out    std_logic;
      tm_cycles_o     : out    std_logic_vector(27 downto 0);
      tm_time_valid_o : out    std_logic;
      tm_utc_o        : out    std_logic_vector(39 downto 0));
  end component xwr_pps_gen;

  component xwr_softpll_ng
    generic(
      g_tag_bits             : integer;
      g_num_ref_inputs       : integer := 1;
      g_num_outputs          : integer := 1;
      g_with_debug_fifo      : boolean := false;
      g_with_ext_clock_input : boolean := false;
      g_reverse_dmtds        : boolean := true;
      g_divide_input_by_2    : boolean := false;
      g_interface_mode       : t_wishbone_interface_mode := pipelined;
      g_address_granularity  : t_wishbone_address_granularity := byte;
      g_ref_clock_rate       : integer := 125000000;
      g_ext_clock_rate       : integer := 10000000);
    port (
      clk_sys_i            : in     std_logic;
      rst_n_i              : in     std_logic;
      clk_ref_i            : in     std_logic_vector(g_num_ref_inputs-1 downto 0);
      clk_fb_i             : in     std_logic_vector(g_num_outputs-1 downto 0);
      clk_dmtd_i           : in     std_logic;
      clk_ext_i            : in     std_logic;
      dac_dmtd_data_o      : out    std_logic_vector(15 downto 0);
      dac_dmtd_load_o      : out    std_logic;
      dac_out_data_o       : out    std_logic_vector(15 downto 0);
      dac_out_sel_o        : out    std_logic_vector(3 downto 0);
      dac_out_load_o       : out    std_logic;
      out_enable_i         : in     std_logic_vector(g_num_outputs-1 downto 0);
      out_locked_o         : out    std_logic_vector(g_num_outputs-1 downto 0);
      slave_i              : in     t_wishbone_slave_in;
      slave_o              : out    t_wishbone_slave_out;
      debug_o              : out    std_logic_vector(5 downto 0);
      dbg_fifo_irq_o       : out    std_logic;
      clk_ext_mul_i        : in     std_logic;
      pps_csync_p1_i       : in     std_logic;
      pps_ext_a_i          : in     std_logic;
      out_status_o         : out    std_logic_vector(4*g_num_outputs-1 downto 0);
      clk_ext_mul_locked_i : in     std_logic := '1');
  end component xwr_softpll_ng;

  component xwr_mini_nic
    generic(
      g_interface_mode       : t_wishbone_interface_mode := classic;
      g_address_granularity  : t_wishbone_address_granularity := word;
      g_memsize_log2         : integer := 14;
      g_buffer_little_endian : boolean := false);
    port (
      clk_sys_i           : in     std_logic;
      rst_n_i             : in     std_logic;
      mem_data_o          : out    std_logic_vector(31 downto 0);
      mem_addr_o          : out    std_logic_vector(g_memsize_log2-1 downto 0);
      mem_data_i          : in     std_logic_vector(31 downto 0);
      mem_wr_o            : out    std_logic;
      src_o               : out    t_wrf_source_out;
      src_i               : in     t_wrf_source_in;
      snk_o               : out    t_wrf_sink_out;
      snk_i               : in     t_wrf_sink_in;
      txtsu_port_id_i     : in     std_logic_vector(4 downto 0);
      txtsu_frame_id_i    : in     std_logic_vector(16 - 1 downto 0);
      txtsu_tsval_i       : in     std_logic_vector(28 + 4 - 1 downto 0);
      txtsu_tsincorrect_i : in     std_logic;
      txtsu_stb_i         : in     std_logic;
      txtsu_ack_o         : out    std_logic;
      wb_i                : in     t_wishbone_slave_in;
      wb_o                : out    t_wishbone_slave_out);
  end component xwr_mini_nic;

begin
  dio_o <= "0000";
  rst_aux_n_o <= rst_net_n;
  led_link_o <= ep_led_link;
  tm_link_up_o <= ep_led_link;
  link_ok_o <= ep_led_link;
  ext_snk_o <= mux_snk_out(1);
  mux_snk_in(1) <= ext_snk_i;
  ext_src_o <= mux_src_out(1);
  mux_src_in(1) <= ext_src_i;

  PPS_GEN: xwr_pps_gen
    generic map(
      g_interface_mode       => PIPELINED,
      g_address_granularity  => BYTE,
      g_ref_clock_rate       => 125000000,
      g_ext_clock_rate       => 10000000,
      g_with_ext_clock_input => g_with_external_clock_input)
    port map(
      clk_ref_i       => clk_ref_i,
      clk_sys_i       => clk_sys_i,
      clk_ext_i       => clk_ext_i,
      rst_n_i         => rst_net_n,
      slave_i         => ppsg_wb_in,
      slave_o         => ppsg_wb_out,
      pps_in_i        => pps_ext_i,
      pps_csync_o     => s_pps_csync,
      pps_out_o       => pps_o,
      pps_led_o       => pps_led_o,
      pps_valid_o     => pps_valid,
      tm_cycles_o     => tm_cycles_o,
      tm_time_valid_o => tm_time_valid_o,
      tm_utc_o        => tm_tai_o);

  U_SOFTPLL: xwr_softpll_ng
    generic map(
      g_tag_bits             => 22,
      g_num_ref_inputs       => 1,
      g_num_outputs          => 1 + g_aux_clks,
      g_with_debug_fifo      => g_softpll_enable_debugger,
      g_with_ext_clock_input => g_with_external_clock_input,
      g_reverse_dmtds        => false,
      g_divide_input_by_2    => not g_pcs_16bit,
      g_interface_mode       => PIPELINED,
      g_address_granularity  => BYTE,
      g_ref_clock_rate       => 125000000,
      g_ext_clock_rate       => 10000000)
    port map(
      clk_sys_i            => clk_sys_i,
      rst_n_i              => rst_net_n,
      clk_ref_i            => U_SOFTPLL_clk_ref_i,
      clk_fb_i             => clk_fb,
      clk_dmtd_i           => clk_dmtd_i,
      clk_ext_i            => clk_ext_i,
      dac_dmtd_data_o      => dac_hpll_data_o,
      dac_dmtd_load_o      => dac_hpll_load_p1_o,
      dac_out_data_o       => dac_dpll_data,
      dac_out_sel_o        => dac_dpll_sel,
      dac_out_load_o       => dac_dpll_load_p1,
      out_enable_i         => out_enable,
      out_locked_o         => spll_out_locked,
      slave_i              => spll_wb_in,
      slave_o              => spll_wb_out,
      debug_o              => open,
      dbg_fifo_irq_o       => open,
      clk_ext_mul_i        => clk_ext_mul_i,
      pps_csync_p1_i       => s_pps_csync,
      pps_ext_a_i          => pps_ext_i,
      out_status_o         => open,
      clk_ext_mul_locked_i => clk_ext_mul_locked_i);

  U_Endpoint: xwr_endpoint
    generic map(
      g_interface_mode        => PIPELINED,
      g_address_granularity   => BYTE,
      g_simulation            => f_int_to_bool(g_simulation),
      g_pcs_16bit             => g_pcs_16bit,
      g_rx_buffer_size        => g_rx_buffer_size,
      g_with_rx_buffer        => true,
      g_with_flow_control     => false,
      g_with_timestamper      => true,
      g_with_dpi_classifier   => true,
      g_with_vlans            => false,
      g_with_rtu              => false,
      g_with_leds             => true,
      g_tx_force_gap_length   => 0,
      g_with_dmtd             => false,
      g_tx_runt_padding       => g_tx_runt_padding,
      g_with_packet_injection => false,
      g_use_new_rxcrc         => true,
      g_use_new_txcrc         => false,
      g_with_stop_traffic     => false)
    port map(
      clk_ref_i                 => clk_ref_i,
      clk_sys_i                 => clk_sys_i,
      clk_dmtd_i                => clk_dmtd_i,
      rst_n_i                   => rst_net_n,
      pps_csync_p1_i            => s_pps_csync,
      pps_valid_i               => pps_valid,
      phy_rst_o                 => phy_rst_o,
      phy_loopen_o              => phy_loopen_o,
      phy_enable_o              => open,
      phy_syncen_o              => open,
      phy_ref_clk_i             => phy_ref_clk_i,
      phy_tx_data_o             => phy_tx_data_o,
      phy_tx_k_o                => phy_tx_k_o,
      phy_tx_disparity_i        => phy_tx_disparity_i,
      phy_tx_enc_err_i          => phy_tx_enc_err_i,
      phy_rx_data_i             => phy_rx_data_i,
      phy_rx_clk_i              => phy_rx_rbclk_i,
      phy_rx_k_i                => phy_rx_k_i,
      phy_rx_enc_err_i          => phy_rx_enc_err_i,
      phy_rx_bitslide_i         => phy_rx_bitslide_i,
      gmii_tx_clk_i             => open,
      gmii_txd_o                => open,
      gmii_tx_en_o              => open,
      gmii_tx_er_o              => open,
      gmii_rx_clk_i             => open,
      gmii_rxd_i                => open,
      gmii_rx_er_i              => open,
      gmii_rx_dv_i              => open,
      src_o                     => ep_src_out,
      src_i                     => ep_src_in,
      snk_o                     => ep_snk_out,
      snk_i                     => ep_snk_in,
      txtsu_port_id_o           => ep_txtsu_port_id,
      txtsu_frame_id_o          => ep_txtsu_frame_id,
      txtsu_ts_value_o          => ep_txtsu_ts_value,
      txtsu_ts_incorrect_o      => ep_txtsu_ts_incorrect,
      txtsu_stb_o               => ep_txtsu_stb,
      txtsu_ack_i               => ep_txtsu_ack,
      rtu_full_i                => open,
      rtu_almost_full_i         => open,
      rtu_rq_strobe_p1_o        => open,
      rtu_rq_smac_o             => open,
      rtu_rq_dmac_o             => open,
      rtu_rq_vid_o              => open,
      rtu_rq_has_vid_o          => open,
      rtu_rq_prio_o             => open,
      rtu_rq_has_prio_o         => open,
      wb_i                      => ep_wb_in,
      wb_o                      => ep_wb_out,
      led_link_o                => ep_led_link,
      led_act_o                 => led_act_o,
      rtu_rq_abort_o            => open,
      pfilter_pclass_o          => open,
      pfilter_drop_o            => open,
      pfilter_done_o            => open,
      fc_tx_pause_req_i         => fc_tx_pause_req_i,
      fc_tx_pause_delay_i       => fc_tx_pause_delay_i,
      fc_tx_pause_ready_o       => fc_tx_pause_ready_o,
      fc_rx_pause_start_p_o     => open,
      fc_rx_pause_quanta_o      => open,
      fc_rx_pause_prio_mask_o   => open,
      fc_rx_buffer_occupation_o => open,
      inject_req_i              => open,
      inject_ready_o            => open,
      inject_packet_sel_i       => open,
      inject_user_value_i       => open,
      rmon_events_o             => open,
      link_kill_i               => open,
      link_up_o                 => open,
      dbg_tx_pcs_wr_count_o     => open,
      dbg_tx_pcs_rd_count_o     => open,
      phy_tx_prbs_sel_o         => phy_tx_prbs_sel_o,
      phy_sfp_tx_fault_i        => phy_sfp_tx_fault_i,
      phy_sfp_los_i             => phy_sfp_los_i,
      phy_sfp_tx_disable_o      => phy_sfp_tx_disable_o,
      phy_loopen_vec_o          => phy_loopen_vec_o,
      phy_rdy_i                 => phy_rdy_i,
      stop_traffic_i            => '0',
      nice_dbg_o                => open,
      txts_o                    => txts_o,
      rxts_o                    => rxts_o);

  MINI_NIC: xwr_mini_nic
    generic map(
      g_interface_mode       => PIPELINED,
      g_address_granularity  => BYTE,
      g_memsize_log2         => f_log2_size(g_dpram_size),
      g_buffer_little_endian => false)
    port map(
      clk_sys_i           => clk_sys_i,
      rst_n_i             => rst_net_n,
      mem_data_o          => mnic_mem_data_o,
      mem_addr_o          => mnic_mem_addr_o,
      mem_data_i          => mnic_mem_data_i,
      mem_wr_o            => mnic_mem_wr_o,
      src_o               => mux_snk_in(0),
      src_i               => mux_snk_out(0),
      snk_o               => mux_src_in(0),
      snk_i               => mux_src_out(0),
      txtsu_port_id_i     => ep_txtsu_port_id,
      txtsu_frame_id_i    => ep_txtsu_frame_id,
      txtsu_tsval_i       => ep_txtsu_ts_value,
      txtsu_tsincorrect_i => ep_txtsu_ts_incorrect,
      txtsu_stb_i         => mnic_txtsu_stb,
      txtsu_ack_o         => mnic_txtsu_ack,
      wb_i                => minic_wb_in,
      wb_o                => minic_wb_out);

  LM32_CORE: xwb_lm32
    generic map(
      g_profile      => "medium_icache_debug",
      g_reset_vector => X"00000000")
    port map(
      clk_sys_i => clk_sys_i,
      rst_n_i   => rst_wrc_n,
      irq_i     => lm32_irq_slv,
      dwb_o     => dwb_o,
      dwb_i     => dwb_i,
      iwb_o     => iwb_o,
      iwb_i     => iwb_i);

  DPRAM: xwb_dpram
    generic map(
      g_size                  => g_dpram_size,
      g_init_file             => f_choose_lm32_firmware_file,
      g_must_have_init_file   => f_check_if_lm32_firmware_necessary,
      g_slave1_interface_mode => PIPELINED,
      g_slave2_interface_mode => PIPELINED,
      g_slave1_granularity    => BYTE,
      g_slave2_granularity    => WORD)
    port map(
      clk_sys_i => clk_sys_i,
      rst_n_i   => rst_n_i,
      slave1_i  => slave1_i,
      slave1_o  => slave1_o,
      slave2_i  => dpram_wbb_i,
      slave2_o  => dpram_wbb_o);

  PERIPH: wrc_periph
    generic map(
      g_phys_uart       => g_phys_uart,
      g_virtual_uart    => g_virtual_uart,
      g_cntr_period     => 62500,
      g_mem_words       => g_dpram_size,
      g_vuart_fifo_size => g_vuart_fifo_size)
    port map(
      clk_sys_i   => clk_sys_i,
      rst_n_i     => rst_n_i,
      rst_net_n_o => rst_net_n,
      rst_wrc_n_o => rst_wrc_n,
      led_red_o   => open,
      led_green_o => open,
      scl_o       => scl_o,
      scl_i       => scl_i,
      sda_o       => sda_o,
      sda_i       => sda_i,
      sfp_scl_o   => sfp_scl_o,
      sfp_scl_i   => sfp_scl_i,
      sfp_sda_o   => sfp_sda_o,
      sfp_sda_i   => sfp_sda_i,
      sfp_det_i   => sfp_det_i,
      memsize_i   => "0000",
      btn1_i      => btn1_i,
      btn2_i      => btn2_i,
      uart_rxd_i  => uart_rxd_i,
      uart_txd_o  => uart_txd_o,
      owr_pwren_o => owr_pwren_o,
      owr_en_o    => owr_en_o,
      owr_i       => owr_i,
      slave_i     => periph_slave_i,
      slave_o     => periph_slave_o,
      spi_sclk_o  => spi_sclk_o,
      spi_ncs_o   => spi_ncs_o,
      spi_mosi_o  => spi_mosi_o,
      spi_miso_i  => spi_miso_i);

  WB_CON: xwb_sdb_crossbar
    generic map(
      g_num_masters => 3,
      g_num_slaves  => 2,
      g_registered  => true,
      g_wraparound  => true,
      g_layout      => c_layout,
      g_sdb_addr    => c_sdb_address)
    port map(
      clk_sys_i => clk_sys_i,
      rst_n_i   => rst_n_i,
      slave_i   => cbar_slave_i,
      slave_o   => cbar_slave_o,
      master_i  => cbar_master_i,
      master_o  => cbar_master_o);

  WB_SECONDARY_CON: xwb_sdb_crossbar
    generic map(
      g_num_masters => 1,
      g_num_slaves  => 8,
      g_registered  => true,
      g_wraparound  => true,
      g_layout      => c_secbar_layout,
      g_sdb_addr    => c_secbar_sdb_address)
    port map(
      clk_sys_i => clk_sys_i,
      rst_n_i   => rst_n_i,
      slave_i   => slave0_i,
      slave_o   => slave0_o,
      master_i  => secbar_master_i,
      master_o  => secbar_master_o);

  U_WBP_MUX: xwrf_mux
    generic map(
      g_muxed_ports => 2)
    port map(
      clk_sys_i   => clk_sys_i,
      rst_n_i     => rst_n_i,
      ep_src_o    => ep_snk_in,
      ep_src_i    => ep_snk_out,
      ep_snk_o    => ep_src_in,
      ep_snk_i    => ep_src_out,
      mux_src_o   => mux_src_out,
      mux_src_i   => mux_src_in,
      mux_snk_o   => mux_snk_out,
      mux_snk_i   => mux_snk_in,
      mux_class_i => mux_class);
    lm32_irq_slv(31 downto 1) <= (others => '0');
    lm32_irq_slv(0)           <= softpll_irq;  -- according to the doc, it's active low.

    out_enable(0)                   <= '1';
    out_enable(g_aux_clks downto 1) <= tm_clk_aux_lock_en_i;  

    dac_dpll_data_o    <= dac_dpll_data;
    dac_dpll_load_p1_o <= '1' when (dac_dpll_load_p1 = '1' and dac_dpll_sel = x"0") else '0';

    tm_dac_value_o <= x"00" & dac_dpll_data;

    p_decode_dac_writes : process(dac_dpll_load_p1, dac_dpll_sel)
    begin
      for i in 0 to g_aux_clks-1 loop
        if dac_dpll_sel = std_logic_vector(to_unsigned(i+1, 4)) then
          tm_dac_wr_o(i) <= dac_dpll_load_p1;
        else
          tm_dac_wr_o(i) <= '0';
        end if;
      end loop;  -- i
    end process;

    locked_spll : if g_aux_clks > 0 generate
      tm_clk_aux_locked_o <= spll_out_locked(g_aux_clks downto 1);
    end generate;

  cbar_master_i(0) <= slave1_o;
  slave1_i <= cbar_master_o(0);

  slave0_i(0) <= cbar_master_o(1);
  cbar_master_i(1) <= slave0_o(0);
    dpram_wbb_i.cyc                                 <= '1';
    dpram_wbb_i.stb                                 <= '1';
    dpram_wbb_i.adr(c_mnic_memsize_log2-1 downto 0) <= mnic_mem_addr_o;
    dpram_wbb_i.sel                                 <= "1111";
    dpram_wbb_i.we                                  <= mnic_mem_wr_o;
    dpram_wbb_i.dat                                 <= mnic_mem_data_o;
    mnic_mem_data_i                                 <= dpram_wbb_o.dat;



  dwb_i <= cbar_slave_o(0);
  cbar_slave_i(0) <=    dwb_o;

  iwb_i <= cbar_slave_o(1);
  cbar_slave_i(1) <=    iwb_o;

  wb_o  <= cbar_slave_o(2);
  cbar_slave_i(2) <=    wb_i;

    secbar_master_i(0) <= minic_wb_out;
    minic_wb_in        <= secbar_master_o(0);
    secbar_master_i(1) <= ep_wb_out;
    ep_wb_in           <= secbar_master_o(1);
    secbar_master_i(2) <= spll_wb_out;
    spll_wb_in         <= secbar_master_o(2);
    secbar_master_i(3) <= ppsg_wb_out;
    ppsg_wb_in         <= secbar_master_o(3);
    --peripherials
    secbar_master_i(4) <= periph_slave_o(0);
    secbar_master_i(5) <= periph_slave_o(1);
    secbar_master_i(6) <= periph_slave_o(2);
    periph_slave_i(0)  <= secbar_master_o(4);
    periph_slave_i(1)  <= secbar_master_o(5);
    periph_slave_i(2)  <= secbar_master_o(6);


    aux_master_o       <= secbar_master_o(7);
    secbar_master_i(7) <= aux_master_i;



    clk_fb(0) <= clk_ref_i;
    clk_fb(g_aux_clks downto 1) <= clk_aux_i;

    softpll_irq <= spll_wb_out.int;

    txtsu_port_id_o      <= ep_txtsu_port_id;
    txtsu_frame_id_o     <= ep_txtsu_frame_id;
    txtsu_ts_value_o     <= ep_txtsu_ts_value;
    txtsu_ts_incorrect_o <= ep_txtsu_ts_incorrect;
    txtsu_stb_o          <= '1' when (ep_txtsu_stb = '1' and (ep_txtsu_frame_id /= x"0000")) else
                            '0';


    U_SOFTPLL_clk_ref_i(0) <= phy_rx_rbclk_i;

    mux_class(0)  <= x"0f";
    mux_class(1)  <= x"f0";

    -- ts goes to external I/F
    ep_txtsu_ack <= txtsu_ack_i or mnic_txtsu_ack;
    -- ts goes to minic
    mnic_txtsu_stb      <=  '1' when (ep_txtsu_stb = '1' and (ep_txtsu_frame_id  = x"0000")) else
                            '0';
end architecture struct ; -- of wr_core

--------------------------------------------------------------------------------
-- Object        : Entity work.xwr_core
-- Last modified : Mon Sep 28 15:45:57 2015.
--------------------------------------------------------------------------------



library ieee, work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.wrcore_pkg.all;
use work.genram_pkg.all;
use work.wishbone_pkg.all;
use work.endpoint_pkg.all;
use work.wr_fabric_pkg.all;
use work.sysc_wbgen2_pkg.all;
use work.softpll_pkg.all;

entity xwr_core is
  generic(
    g_simulation                : integer := 0;
    g_phys_uart                 : boolean := true;
    g_virtual_uart              : boolean := false;
    g_with_external_clock_input : boolean := false;
    g_aux_clks                  : integer := 1;
    g_ep_rxbuf_size             : integer := 1024;
    g_tx_runt_padding           : boolean := false;
    g_dpram_initf               : string := "";
    g_dpram_size                : integer := 90112/4;
    g_interface_mode            : t_wishbone_interface_mode := PIPELINED;
    g_address_granularity       : t_wishbone_address_granularity := WORD;
    g_aux_sdb                   : t_sdb_device := c_wrc_periph3_sdb;
    g_softpll_enable_debugger   : boolean := false;
    g_vuart_fifo_size           : integer := 1024;
    g_pcs_16bit                 : boolean := false;
    g_ref_clock_rate            : integer := 125000000;
    g_ext_clock_rate            : integer := 10000000);
  port (
    aux_master_i         : in     t_wishbone_master_in := cc_dummy_master_in;
    aux_master_o         : out    t_wishbone_master_out;
    btn1_i               : in     std_logic := '1';
    btn2_i               : in     std_logic := '1';
    clk_aux_i            : in     std_logic_vector(g_aux_clks-1 downto 0) := (OTHERS => '0');
    clk_dmtd_i           : in     std_logic;
    clk_ext_i            : in     std_logic := '0';
    clk_ext_mul_i        : in     std_logic := '0';
    clk_ext_mul_locked_i : in     std_logic := '1';
    clk_ref_i            : in     std_logic;
    clk_sys_i            : in     std_logic;
    dac_dpll_data_o      : out    std_logic_vector(15 downto 0);
    dac_dpll_load_p1_o   : out    std_logic;
    dac_hpll_data_o      : out    std_logic_vector(15 downto 0);
    dac_hpll_load_p1_o   : out    std_logic;
    dio_o                : out    std_logic_vector(3 downto 0);
    fc_tx_pause_delay_i  : in     std_logic_vector(15 downto 0) := x"0000";
    fc_tx_pause_ready_o  : out    std_logic;
    fc_tx_pause_req_i    : in     std_logic := '0';
    led_act_o            : out    std_logic;
    led_link_o           : out    std_logic;
    link_ok_o            : out    std_logic;
    owr_en_o             : out    std_logic_vector(1 downto 0);
    owr_i                : in     std_logic_vector(1 downto 0) := (OTHERS => '1');
    owr_pwren_o          : out    std_logic_vector(1 downto 0);
    phy_loopen_o         : out    std_logic;
    phy_loopen_vec_o     : out    std_logic_vector(2 downto 0);
    phy_rdy_i            : in     std_logic := '1';
    phy_ref_clk_i        : in     std_logic;
    phy_rst_o            : out    std_logic;
    phy_rx_bitslide_i    : in     std_logic_vector(f_pcs_bts_width(g_pcs_16bit)-1 downto 0);
    phy_rx_data_i        : in     std_logic_vector(f_pcs_data_width(g_pcs_16bit)-1 downto 0);
    phy_rx_enc_err_i     : in     std_logic;
    phy_rx_k_i           : in     std_logic_vector(f_pcs_k_width(g_pcs_16bit)-1 downto 0);
    phy_rx_rbclk_i       : in     std_logic;
    phy_sfp_los_i        : in     std_logic;
    phy_sfp_tx_disable_o : out    std_logic;
    phy_sfp_tx_fault_i   : in     std_logic;
    phy_tx_data_o        : out    std_logic_vector(f_pcs_data_width(g_pcs_16bit)-1 downto 0);
    phy_tx_disparity_i   : in     std_logic;
    phy_tx_enc_err_i     : in     std_logic;
    phy_tx_k_o           : out    std_logic_vector(f_pcs_k_width(g_pcs_16bit)-1 downto 0);
    phy_tx_prbs_sel_o    : out    std_logic_vector(2 downto 0);
    pps_ext_i            : in     std_logic := '0';
    pps_led_o            : out    std_logic;
    pps_p_o              : out    std_logic;
    rst_aux_n_o          : out    std_logic;
    rst_n_i              : in     std_logic;
    rxts_o               : out    std_logic;
    scl_i                : in     std_logic := '1';
    scl_o                : out    std_logic;
    sda_i                : in     std_logic := '1';
    sda_o                : out    std_logic;
    sfp_det_i            : in     std_logic;
    sfp_scl_i            : in     std_logic := '1';
    sfp_scl_o            : out    std_logic;
    sfp_sda_i            : in     std_logic := '1';
    sfp_sda_o            : out    std_logic;
    slave_i              : in     t_wishbone_slave_in := cc_dummy_slave_in;
    slave_o              : out    t_wishbone_slave_out;
    spi_miso_i           : in     std_logic := '0';
    spi_mosi_o           : out    std_logic;
    spi_ncs_o            : out    std_logic;
    spi_sclk_o           : out    std_logic;
    timestamps_ack_i     : in     std_logic := '1';
    timestamps_o         : out    t_txtsu_timestamp;
    tm_clk_aux_lock_en_i : in     std_logic_vector(g_aux_clks-1 downto 0) := (OTHERS => '0');
    tm_clk_aux_locked_o  : out    std_logic_vector(g_aux_clks-1 downto 0);
    tm_cycles_o          : out    std_logic_vector(27 downto 0);
    tm_dac_value_o       : out    std_logic_vector(23 downto 0);
    tm_dac_wr_o          : out    std_logic_vector(g_aux_clks-1 downto 0);
    tm_link_up_o         : out    std_logic;
    tm_tai_o             : out    std_logic_vector(39 downto 0);
    tm_time_valid_o      : out    std_logic;
    txts_o               : out    std_logic;
    uart_rxd_i           : in     std_logic := '0';
    uart_txd_o           : out    std_logic;
    wrf_snk_i            : in     t_wrf_sink_in := c_dummy_snk_in;
    wrf_snk_o            : out    t_wrf_sink_out;
    wrf_src_i            : in     t_wrf_source_in := c_dummy_src_in;
    wrf_src_o            : out    t_wrf_source_out);
end entity xwr_core;

--------------------------------------------------------------------------------
-- Object        : Architecture work.xwr_core.struct
-- Last modified : Mon Sep 28 15:45:57 2015.
--------------------------------------------------------------------------------

architecture struct of xwr_core is

  signal txtsu_port_id_o      : std_logic_vector(4 downto 0);
  signal txtsu_frame_id_o     : std_logic_vector(15 downto 0);
  signal txtsu_ts_value_o     : std_logic_vector(31 downto 0);
  signal txtsu_ts_incorrect_o : std_logic;
  signal txtsu_stb_o          : std_logic;

  component wr_core
    generic(
      g_with_external_clock_input : boolean := false;
      g_aux_clks                  : integer := 1;
      g_pcs_16bit                 : boolean := false;
      g_rx_buffer_size            : integer := 1024;
      g_dpram_size                : integer := 90112/4;  --in 32-bit words;
      g_phys_uart                 : boolean := true;
      g_virtual_uart              : boolean := false;
      g_interface_mode            : t_wishbone_interface_mode := PIPELINED;
      g_address_granularity       : t_wishbone_address_granularity := WORD;
      g_simulation                : integer := 0;
      g_aux_sdb                   : t_sdb_device := c_wrc_periph3_sdb;
      g_softpll_enable_debugger   : boolean := false;
      g_tx_runt_padding           : boolean := false;
      g_vuart_fifo_size           : integer := 1024;
      g_dpram_initf               : string := "default";
      g_ref_clock_rate            : integer := 125000000;
      g_ext_clock_rate            : integer := 10000000);
    port (
      aux_master_i         : in     t_wishbone_master_in;
      aux_master_o         : out    t_wishbone_master_out;
      btn1_i               : in     std_logic := '1';
      btn2_i               : in     std_logic := '1';
      clk_aux_i            : in     std_logic_vector(g_aux_clks-1 downto 0) := (others => '0');
      clk_dmtd_i           : in     std_logic;
      clk_ext_i            : in     std_logic := '0';
      clk_ext_mul_i        : in     std_logic := '0';
      clk_ext_mul_locked_i : in     std_logic := '1';
      clk_ref_i            : in     std_logic;
      clk_sys_i            : in     std_logic;
      dac_dpll_data_o      : out    std_logic_vector(15 downto 0);
      dac_dpll_load_p1_o   : out    std_logic;
      dac_hpll_data_o      : out    std_logic_vector(15 downto 0);
      dac_hpll_load_p1_o   : out    std_logic;
      dio_o                : out    std_logic_vector(3 downto 0);
      ext_snk_i            : in     t_wrf_sink_in;
      ext_snk_o            : out    t_wrf_sink_out;
      ext_src_i            : in     t_wrf_source_in;
      ext_src_o            : out    t_wrf_source_out;
      fc_tx_pause_delay_i  : in     std_logic_vector(15 downto 0) := x"0000";
      fc_tx_pause_ready_o  : out    std_logic;
      fc_tx_pause_req_i    : in     std_logic := '0';
      led_act_o            : out    std_logic;
      led_link_o           : out    std_logic;
      link_ok_o            : out    std_logic;
      owr_en_o             : out    std_logic_vector(1 downto 0);
      owr_i                : in     std_logic_vector(1 downto 0) := (others => '1');
      owr_pwren_o          : out    std_logic_vector(1 downto 0);
      phy_loopen_o         : out    std_logic;
      phy_loopen_vec_o     : out    std_logic_vector(2 downto 0);
      phy_rdy_i            : in     std_logic := '1';
      phy_ref_clk_i        : in     std_logic;
      phy_rst_o            : out    std_logic;
      phy_rx_bitslide_i    : in     std_logic_vector(f_pcs_bts_width(g_pcs_16bit)-1 downto 0);
      phy_rx_data_i        : in     std_logic_vector(f_pcs_data_width(g_pcs_16bit)-1 downto 0);
      phy_rx_enc_err_i     : in     std_logic;
      phy_rx_k_i           : in     std_logic_vector(f_pcs_k_width(g_pcs_16bit)-1 downto 0) := (others=>'0');
      phy_rx_rbclk_i       : in     std_logic;
      phy_sfp_los_i        : in     std_logic := '0';
      phy_sfp_tx_disable_o : out    std_logic;
      phy_sfp_tx_fault_i   : in     std_logic := '0';
      phy_tx_data_o        : out    std_logic_vector(f_pcs_data_width(g_pcs_16bit)-1 downto 0);
      phy_tx_disparity_i   : in     std_logic;
      phy_tx_enc_err_i     : in     std_logic;
      phy_tx_k_o           : out    std_logic_vector(f_pcs_k_width(g_pcs_16bit)-1 downto 0);
      phy_tx_prbs_sel_o    : out    std_logic_vector(2 downto 0);
      pps_ext_i            : in     std_logic := '0';
      pps_led_o            : out    std_logic;
      pps_o                : out    std_logic;
      rst_aux_n_o          : out    std_logic;
      rst_n_i              : in     std_logic;
      rxts_o               : out    std_logic;
      scl_i                : in     std_logic := '1';
      scl_o                : out    std_logic;
      sda_i                : in     std_logic := '1';
      sda_o                : out    std_logic;
      sfp_det_i            : in     std_logic := '1';
      sfp_scl_i            : in     std_logic := '1';
      sfp_scl_o            : out    std_logic;
      sfp_sda_i            : in     std_logic := '1';
      sfp_sda_o            : out    std_logic;
      spi_miso_i           : in     std_logic := '0';
      spi_mosi_o           : out    std_logic;
      spi_ncs_o            : out    std_logic;
      spi_sclk_o           : out    std_logic;
      tm_clk_aux_lock_en_i : in     std_logic_vector(g_aux_clks-1 downto 0) := (others => '0');
      tm_clk_aux_locked_o  : out    std_logic_vector(g_aux_clks-1 downto 0);
      tm_cycles_o          : out    std_logic_vector(27 downto 0);
      tm_dac_value_o       : out    std_logic_vector(23 downto 0);
      tm_dac_wr_o          : out    std_logic_vector(g_aux_clks-1 downto 0);
      tm_link_up_o         : out    std_logic;
      tm_tai_o             : out    std_logic_vector(39 downto 0);
      tm_time_valid_o      : out    std_logic;
      txts_o               : out    std_logic;
      txtsu_ack_i          : in     std_logic := '1';
      txtsu_frame_id_o     : out    std_logic_vector(15 downto 0);
      txtsu_port_id_o      : out    std_logic_vector(4 downto 0);
      txtsu_stb_o          : out    std_logic;
      txtsu_ts_incorrect_o : out    std_logic;
      txtsu_ts_value_o     : out    std_logic_vector(31 downto 0);
      uart_rxd_i           : in     std_logic := '1';
      uart_txd_o           : out    std_logic;
      wb_i                 : in     t_wishbone_slave_in;
      wb_o                 : out    t_wishbone_slave_out);
  end component wr_core;

begin

  WRPC: wr_core
    generic map(
      g_with_external_clock_input => g_with_external_clock_input,
      g_aux_clks                  => g_aux_clks,
      g_pcs_16bit                 => g_pcs_16bit,
      g_rx_buffer_size            => g_ep_rxbuf_size,
      g_dpram_size                => g_dpram_size,
      g_phys_uart                 => g_phys_uart,
      g_virtual_uart              => g_virtual_uart,
      g_interface_mode            => g_interface_mode,
      g_address_granularity       => g_address_granularity,
      g_simulation                => g_simulation,
      g_aux_sdb                   => g_aux_sdb,
      g_softpll_enable_debugger   => g_softpll_enable_debugger,
      g_tx_runt_padding           => g_tx_runt_padding,
      g_vuart_fifo_size           => g_vuart_fifo_size,
      g_dpram_initf               => g_dpram_initf,
      g_ref_clock_rate            => g_ref_clock_rate,
      g_ext_clock_rate            => g_ext_clock_rate)
    port map(
      aux_master_i         => aux_master_i,
      aux_master_o         => aux_master_o,
      btn1_i               => btn1_i,
      btn2_i               => btn2_i,
      clk_aux_i            => clk_aux_i,
      clk_dmtd_i           => clk_dmtd_i,
      clk_ext_i            => clk_ext_i,
      clk_ext_mul_i        => clk_ext_mul_i,
      clk_ext_mul_locked_i => clk_ext_mul_locked_i,
      clk_ref_i            => clk_ref_i,
      clk_sys_i            => clk_sys_i,
      dac_dpll_data_o      => dac_dpll_data_o,
      dac_dpll_load_p1_o   => dac_dpll_load_p1_o,
      dac_hpll_data_o      => dac_hpll_data_o,
      dac_hpll_load_p1_o   => dac_hpll_load_p1_o,
      dio_o                => dio_o,
      ext_snk_i            => wrf_snk_i,
      ext_snk_o            => wrf_snk_o,
      ext_src_i            => wrf_src_i,
      ext_src_o            => wrf_src_o,
      fc_tx_pause_delay_i  => fc_tx_pause_delay_i,
      fc_tx_pause_ready_o  => fc_tx_pause_ready_o,
      fc_tx_pause_req_i    => fc_tx_pause_req_i,
      led_act_o            => led_act_o,
      led_link_o           => led_link_o,
      link_ok_o            => link_ok_o,
      owr_en_o             => owr_en_o,
      owr_i                => owr_i,
      owr_pwren_o          => owr_pwren_o,
      phy_loopen_o         => phy_loopen_o,
      phy_loopen_vec_o     => phy_loopen_vec_o,
      phy_rdy_i            => phy_rdy_i,
      phy_ref_clk_i        => phy_ref_clk_i,
      phy_rst_o            => phy_rst_o,
      phy_rx_bitslide_i    => phy_rx_bitslide_i,
      phy_rx_data_i        => phy_rx_data_i,
      phy_rx_enc_err_i     => phy_rx_enc_err_i,
      phy_rx_k_i           => phy_rx_k_i,
      phy_rx_rbclk_i       => phy_rx_rbclk_i,
      phy_sfp_los_i        => phy_sfp_los_i,
      phy_sfp_tx_disable_o => phy_sfp_tx_disable_o,
      phy_sfp_tx_fault_i   => phy_sfp_tx_fault_i,
      phy_tx_data_o        => phy_tx_data_o,
      phy_tx_disparity_i   => phy_tx_disparity_i,
      phy_tx_enc_err_i     => phy_tx_enc_err_i,
      phy_tx_k_o           => phy_tx_k_o,
      phy_tx_prbs_sel_o    => phy_tx_prbs_sel_o,
      pps_ext_i            => pps_ext_i,
      pps_led_o            => pps_led_o,
      pps_o                => pps_p_o,
      rst_aux_n_o          => rst_aux_n_o,
      rst_n_i              => rst_n_i,
      rxts_o               => rxts_o,
      scl_i                => scl_i,
      scl_o                => scl_o,
      sda_i                => sda_i,
      sda_o                => sda_o,
      sfp_det_i            => sfp_det_i,
      sfp_scl_i            => sfp_scl_i,
      sfp_scl_o            => sfp_scl_o,
      sfp_sda_i            => sfp_sda_i,
      sfp_sda_o            => sfp_sda_o,
      spi_miso_i           => spi_miso_i,
      spi_mosi_o           => spi_mosi_o,
      spi_ncs_o            => spi_ncs_o,
      spi_sclk_o           => spi_sclk_o,
      tm_clk_aux_lock_en_i => tm_clk_aux_lock_en_i,
      tm_clk_aux_locked_o  => tm_clk_aux_locked_o,
      tm_cycles_o          => tm_cycles_o,
      tm_dac_value_o       => tm_dac_value_o,
      tm_dac_wr_o          => tm_dac_wr_o,
      tm_link_up_o         => tm_link_up_o,
      tm_tai_o             => tm_tai_o,
      tm_time_valid_o      => tm_time_valid_o,
      txts_o               => txts_o,
      txtsu_ack_i          => timestamps_ack_i,
      txtsu_frame_id_o     => txtsu_frame_id_o,
      txtsu_port_id_o      => txtsu_port_id_o,
      txtsu_stb_o          => txtsu_stb_o,
      txtsu_ts_incorrect_o => txtsu_ts_incorrect_o,
      txtsu_ts_value_o     => txtsu_ts_value_o,
      uart_rxd_i           => uart_rxd_i,
      uart_txd_o           => uart_txd_o,
      wb_i                 => slave_i,
      wb_o                 => slave_o);
  timestamps_o.port_id(4 downto 0) <= txtsu_port_id_o;
  timestamps_o.port_id(5)          <= '0';
  timestamps_o.frame_id            <= txtsu_frame_id_o;
  timestamps_o.tsval               <= txtsu_ts_value_o;
  timestamps_o.incorrect           <= txtsu_ts_incorrect_o;
  timestamps_o.stb                 <= txtsu_stb_o;
end architecture struct ; -- of xwr_core

--------------------------------------------------------------------------------
-- Object        : Entity work.spec_top
-- Last modified : Tue Oct 13 13:08:55 2015.
--------------------------------------------------------------------------------



library ieee, work, UNISIM;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.gencores_pkg.all;
use work.wrcore_pkg.all;
use work.wr_fabric_pkg.all;
use work.endpoint_pkg.all;
use work.etherbone_pkg.all;
use UNISIM.VCOMPONENTS.all;
use work.wishbone_pkg.all;

entity spec_top is
  port (
    GPIO                     : inout  std_logic_vector(1 downto 0);
    L2P_CLKn                 : out    std_logic;
    L2P_CLKp                 : out    std_logic;
    L2P_DATA                 : out    std_logic_vector(15 downto 0);
    L2P_DFRAME               : out    std_logic;
    L2P_EDB                  : out    std_logic;
    L2P_RDY                  : in     std_logic;
    L2P_VALID                : out    std_logic;
    LED_GREEN                : out    std_logic;
    LED_RED                  : out    std_logic;
    L_CLKn                   : in     std_logic;
    L_CLKp                   : in     std_logic;
    L_RST_N                  : in     std_logic;
    L_WR_RDY                 : in     std_logic_vector(1 downto 0);
    P2L_CLKn                 : in     std_logic;
    P2L_CLKp                 : in     std_logic;
    P2L_DATA                 : in     std_logic_vector(15 downto 0);
    P2L_DFRAME               : in     std_logic;
    P2L_RDY                  : out    std_logic;
    P2L_VALID                : in     std_logic;
    P_RD_D_RDY               : in     std_logic_vector(1 downto 0);
    P_WR_RDY                 : out    std_logic_vector(1 downto 0);
    P_WR_REQ                 : in     std_logic_vector(1 downto 0);
    RX_ERROR                 : out    std_logic;
    TX_ERROR                 : in     std_logic;
    VC_RDY                   : in     std_logic_vector(1 downto 0);
    button1_i                : in     std_logic := 'H';
    button2_i                : in     std_logic := 'H';
    clk_125m_pllref_n_i      : in     std_logic;
    clk_125m_pllref_p_i      : in     std_logic;
    clk_20m_vcxo_i           : in     std_logic;
    dac_clr_n_o              : out    std_logic;
    dac_cs1_n_o              : out    std_logic;
    dac_cs2_n_o              : out    std_logic;
    dac_din_o                : out    std_logic;
    dac_sclk_o               : out    std_logic;
    dio_clk_n_i              : in     std_logic;
    dio_clk_p_i              : in     std_logic;
    dio_led_bot_o            : out    std_logic;
    dio_led_top_o            : out    std_logic;
    dio_n_i                  : in     std_logic_vector(4 downto 0);
    dio_n_o                  : out    std_logic_vector(4 downto 0);
    dio_oe_n_o               : out    std_logic_vector(4 downto 0);
    dio_onewire_b            : inout  std_logic;
    dio_p_i                  : in     std_logic_vector(4 downto 0);
    dio_p_o                  : out    std_logic_vector(4 downto 0);
    dio_sdn_ck_n_o           : out    std_logic;
    dio_sdn_n_o              : out    std_logic;
    dio_term_en_o            : out    std_logic_vector(4 downto 0);
    fpga_pll_ref_clk_101_n_i : in     std_logic;
    fpga_pll_ref_clk_101_p_i : in     std_logic;
    fpga_scl_b               : inout  std_logic;
    fpga_sda_b               : inout  std_logic;
    sfp_los_i                : in     std_logic;
    sfp_mod_def0_b           : in     std_logic;
    sfp_mod_def1_b           : inout  std_logic;
    sfp_mod_def2_b           : inout  std_logic;
    sfp_rate_select_b        : inout  std_logic;
    sfp_rxn_i                : in     std_logic;
    sfp_rxp_i                : in     std_logic;
    sfp_tx_disable_o         : out    std_logic;
    sfp_tx_fault_i           : in     std_logic;
    sfp_txn_o                : out    std_logic;
    sfp_txp_o                : out    std_logic;
    spi_miso_i               : in     std_logic := 'L';
    spi_mosi_o               : out    std_logic;
    spi_ncs_o                : out    std_logic;
    spi_sclk_o               : out    std_logic;
    thermo_id                : inout  std_logic;
    uart_rxd_i               : in     std_logic;
    uart_txd_o               : out    std_logic);
end entity spec_top;

--------------------------------------------------------------------------------
-- Object        : Architecture work.spec_top.rtl
-- Last modified : Tue Oct 13 13:08:55 2015.
--------------------------------------------------------------------------------

architecture rtl of spec_top is

    constant c_BAR0_APERTURE     : integer := 20;
    constant c_CSR_WB_SLAVES_NB  : integer := 1;
    constant c_DMA_WB_SLAVES_NB  : integer := 1;
    constant c_DMA_WB_ADDR_WIDTH : integer := 26;
  signal clk_sys              : std_logic;
  signal clk_ext              : std_logic;
  signal clk_ext_mul          : std_logic;
  signal ext_pll_reset        : std_logic;
  signal local_reset          : std_logic;
  signal local_reset_n        : std_logic;
  signal pllout_clk_fb_pllref : std_logic;
  signal pllout_clk_sys       : std_logic;
  signal pllout_clk_fb_dmtd   : std_logic;
  signal pllout_clk_dmtd      : std_logic;
  signal clk_dmtd             : std_logic;
  signal clk_20m_vcxo_buf     : std_logic;
  signal phy_tx_data          : std_logic_vector(7 downto 0);
  signal phy_tx_disparity     : std_logic;
  signal phy_tx_enc_err       : std_logic;
  signal phy_rst              : std_logic;
  signal gtp_dedicated_clk    : std_logic;
  signal wrc_scl_o            : std_logic;
  signal wrc_scl_i            : std_logic;
  signal wrc_sda_o            : std_logic;
  signal wrc_sda_i            : std_logic;
  signal sfp_scl_o            : std_logic;
  signal sfp_scl_i            : std_logic;
  signal sfp_sda_o            : std_logic;
  signal sfp_sda_i            : std_logic;
  signal owr_i                : std_logic_vector(1 downto 0);
  signal dac_dpll_data        : std_logic_vector(15 downto 0);
  signal dac_dpll_load_p1     : std_logic;
  signal dac_hpll_data        : std_logic_vector(15 downto 0);
  signal dac_hpll_load_p1     : std_logic;
  signal dac_cs_n_o           : std_logic_vector(1 downto 0);
  signal clk_125m_pllref      : std_logic;
  signal owr_en               : std_logic_vector(1 downto 0);
  signal wrc_slave_i          : t_wishbone_slave_in;
  signal etherbone_cfg_out    : t_wishbone_slave_out;
  signal etherbone_cfg_in     : t_wishbone_slave_in;
  signal pps_led              : std_logic;
  signal dio_in               : std_logic_vector(4 downto 0);
  signal dio_out              : std_logic_vector(4 downto 0);
  signal pps                  : std_logic;
  signal phy_rx_data          : std_logic_vector(7 downto 0);
  signal phy_rx_bitslide      : std_logic_vector(3 downto 0);
  signal phy_rx_enc_err       : std_logic;
  signal phy_rx_rbclk         : std_logic;
  signal phy_prbs_sel         : std_logic_vector(2 downto 0);
  signal clk_ext_mul_locked   : std_logic;
  signal phy_loopen           : std_logic;
  signal phy_loopen_vec       : std_logic_vector(2 downto 0);
  signal phy_rdy              : std_logic;
  signal etherbone_snk_in     : t_wrf_sink_in;
  signal etherbone_snk_out    : t_wrf_sink_out;
  signal etherbone_src_out    : t_wrf_source_out;
  signal etherbone_src_in     : t_wrf_source_in;
  signal phy_tx_k             : std_logic_vector(0 downto 0);
  signal phy_rx_k             : std_logic_vector(0 downto 0);
  signal csr_dat_o            : std_logic_vector(31 downto 0);
  signal csr_sel_o            : std_logic_vector(3 downto 0);
  signal csr_stb_o            : std_logic;
  signal csr_we_o             : std_logic;
  signal csr_cyc_o            : std_logic;
  signal csr_dat_i            : std_logic_vector(31 downto 0);
  signal genum_csr_ack_i      : std_logic;
  signal csr_stall_i          : std_logic;
  signal dma_reg_adr_i        : std_logic_vector(31 downto 0);
  signal dma_reg_dat_i        : std_logic_vector(31 downto 0);
  signal dma_reg_sel_i        : std_logic_vector(3 downto 0);
  signal dma_reg_stb_i        : std_logic;
  signal dma_reg_we_i         : std_logic;
  signal dma_reg_cyc_i        : std_logic;
  signal dma_reg_dat_o        : std_logic_vector(31 downto 0);
  signal dma_reg_ack_o        : std_logic;
  signal dma_reg_stall_o      : std_logic;
  signal dma_dat_i            : std_logic_vector(31 downto 0);
  signal dma_ack_i            : std_logic;
  signal dma_stall_i          : std_logic;
  signal dma_adr_o            : std_logic_vector(31 downto 0);
  signal dma_dat_o            : std_logic_vector(31 downto 0);
  signal dma_sel_o            : std_logic_vector(3 downto 0);
  signal dma_stb_o            : std_logic;
  signal dma_we_o             : std_logic;
  signal dma_cyc_o            : std_logic;
  signal wb_adr               : std_logic_vector(31 downto 0);
  signal led_divider          : unsigned(23 downto 0);
  signal etherbone_rst_n      : std_logic;
  signal slave_i              : t_wishbone_slave_in_array(2-1 downto 0);
  signal etherbone_wb_out     : t_wishbone_master_out;
  signal slave_o              : t_wishbone_slave_out_array(2-1 downto 0);
  signal etherbone_wb_in      : t_wishbone_master_in;
  signal genum_wb_in          : t_wishbone_master_in;
  signal genum_wb_out         : t_wishbone_master_out;
  signal rst                  : std_logic;
  signal wrc_slave_o          : t_wishbone_slave_out;
  signal master_i             : t_wishbone_master_in_array(1-1 downto 0);
  signal master_o             : t_wishbone_master_out_array(1-1 downto 0);
  signal l_clk                : std_logic;

  component xwr_core
    generic(
      g_simulation                : integer := 0;
      g_phys_uart                 : boolean := true;
      g_virtual_uart              : boolean := false;
      g_with_external_clock_input : boolean := false;
      g_aux_clks                  : integer := 1;
      g_ep_rxbuf_size             : integer := 1024;
      g_tx_runt_padding           : boolean := false;
      g_dpram_initf               : string := "";
      g_dpram_size                : integer := 90112/4;
      g_interface_mode            : t_wishbone_interface_mode := PIPELINED;
      g_address_granularity       : t_wishbone_address_granularity := WORD;
      g_aux_sdb                   : t_sdb_device := c_wrc_periph3_sdb;
      g_softpll_enable_debugger   : boolean := false;
      g_vuart_fifo_size           : integer := 1024;
      g_pcs_16bit                 : boolean := false;
      g_ref_clock_rate            : integer := 125000000;
      g_ext_clock_rate            : integer := 10000000);
    port (
      aux_master_i         : in     t_wishbone_master_in := cc_dummy_master_in;
      aux_master_o         : out    t_wishbone_master_out;
      btn1_i               : in     std_logic := '1';
      btn2_i               : in     std_logic := '1';
      clk_aux_i            : in     std_logic_vector(g_aux_clks-1 downto 0) := (OTHERS => '0');
      clk_dmtd_i           : in     std_logic;
      clk_ext_i            : in     std_logic := '0';
      clk_ext_mul_i        : in     std_logic := '0';
      clk_ext_mul_locked_i : in     std_logic := '1';
      clk_ref_i            : in     std_logic;
      clk_sys_i            : in     std_logic;
      dac_dpll_data_o      : out    std_logic_vector(15 downto 0);
      dac_dpll_load_p1_o   : out    std_logic;
      dac_hpll_data_o      : out    std_logic_vector(15 downto 0);
      dac_hpll_load_p1_o   : out    std_logic;
      dio_o                : out    std_logic_vector(3 downto 0);
      fc_tx_pause_delay_i  : in     std_logic_vector(15 downto 0) := x"0000";
      fc_tx_pause_ready_o  : out    std_logic;
      fc_tx_pause_req_i    : in     std_logic := '0';
      led_act_o            : out    std_logic;
      led_link_o           : out    std_logic;
      link_ok_o            : out    std_logic;
      owr_en_o             : out    std_logic_vector(1 downto 0);
      owr_i                : in     std_logic_vector(1 downto 0) := (OTHERS => '1');
      owr_pwren_o          : out    std_logic_vector(1 downto 0);
      phy_loopen_o         : out    std_logic;
      phy_loopen_vec_o     : out    std_logic_vector(2 downto 0);
      phy_rdy_i            : in     std_logic := '1';
      phy_ref_clk_i        : in     std_logic;
      phy_rst_o            : out    std_logic;
      phy_rx_bitslide_i    : in     std_logic_vector(f_pcs_bts_width(g_pcs_16bit)-1 downto 0);
      phy_rx_data_i        : in     std_logic_vector(f_pcs_data_width(g_pcs_16bit)-1 downto 0);
      phy_rx_enc_err_i     : in     std_logic;
      phy_rx_k_i           : in     std_logic_vector(f_pcs_k_width(g_pcs_16bit)-1 downto 0);
      phy_rx_rbclk_i       : in     std_logic;
      phy_sfp_los_i        : in     std_logic;
      phy_sfp_tx_disable_o : out    std_logic;
      phy_sfp_tx_fault_i   : in     std_logic;
      phy_tx_data_o        : out    std_logic_vector(f_pcs_data_width(g_pcs_16bit)-1 downto 0);
      phy_tx_disparity_i   : in     std_logic;
      phy_tx_enc_err_i     : in     std_logic;
      phy_tx_k_o           : out    std_logic_vector(f_pcs_k_width(g_pcs_16bit)-1 downto 0);
      phy_tx_prbs_sel_o    : out    std_logic_vector(2 downto 0);
      pps_ext_i            : in     std_logic := '0';
      pps_led_o            : out    std_logic;
      pps_p_o              : out    std_logic;
      rst_aux_n_o          : out    std_logic;
      rst_n_i              : in     std_logic;
      rxts_o               : out    std_logic;
      scl_i                : in     std_logic := '1';
      scl_o                : out    std_logic;
      sda_i                : in     std_logic := '1';
      sda_o                : out    std_logic;
      sfp_det_i            : in     std_logic;
      sfp_scl_i            : in     std_logic := '1';
      sfp_scl_o            : out    std_logic;
      sfp_sda_i            : in     std_logic := '1';
      sfp_sda_o            : out    std_logic;
      slave_i              : in     t_wishbone_slave_in := cc_dummy_slave_in;
      slave_o              : out    t_wishbone_slave_out;
      spi_miso_i           : in     std_logic := '0';
      spi_mosi_o           : out    std_logic;
      spi_ncs_o            : out    std_logic;
      spi_sclk_o           : out    std_logic;
      timestamps_ack_i     : in     std_logic := '1';
      timestamps_o         : out    t_txtsu_timestamp;
      tm_clk_aux_lock_en_i : in     std_logic_vector(g_aux_clks-1 downto 0) := (OTHERS => '0');
      tm_clk_aux_locked_o  : out    std_logic_vector(g_aux_clks-1 downto 0);
      tm_cycles_o          : out    std_logic_vector(27 downto 0);
      tm_dac_value_o       : out    std_logic_vector(23 downto 0);
      tm_dac_wr_o          : out    std_logic_vector(g_aux_clks-1 downto 0);
      tm_link_up_o         : out    std_logic;
      tm_tai_o             : out    std_logic_vector(39 downto 0);
      tm_time_valid_o      : out    std_logic;
      txts_o               : out    std_logic;
      uart_rxd_i           : in     std_logic := '0';
      uart_txd_o           : out    std_logic;
      wrf_snk_i            : in     t_wrf_sink_in := c_dummy_snk_in;
      wrf_snk_o            : out    t_wrf_sink_out;
      wrf_src_i            : in     t_wrf_source_in := c_dummy_src_in;
      wrf_src_o            : out    t_wrf_source_out);
  end component xwr_core;

  component spec_reset_gen
    port (
      clk_sys_i        : in     std_logic;
      rst_pcie_n_a_i   : in     std_logic;
      rst_button_n_a_i : in     std_logic;
      rst_n_o          : out    std_logic);
  end component spec_reset_gen;

  component ext_pll_10_to_125m
    port (
      clk_ext_i     : in     std_logic;
      clk_ext_mul_o : out    std_logic;
      rst_a_i       : in     std_logic;
      locked_o      : out    std_logic);
  end component ext_pll_10_to_125m;

  component spec_serial_dac_arb
    generic(
      g_invert_sclk    : boolean;
      g_num_extra_bits : integer);
    port (
      clk_i       : in     std_logic;
      rst_n_i     : in     std_logic;
      val1_i      : in     std_logic_vector(15 downto 0);
      load1_i     : in     std_logic;
      val2_i      : in     std_logic_vector(15 downto 0);
      load2_i     : in     std_logic;
      dac_cs_n_o  : out    std_logic_vector(1 downto 0);
      dac_clr_n_o : out    std_logic;
      dac_sclk_o  : out    std_logic;
      dac_din_o   : out    std_logic);
  end component spec_serial_dac_arb;

  component gn4124_core
    port (
      rst_n_a_i       : in     std_logic;
      status_o        : out    std_logic_vector(31 downto 0);
      p2l_clk_p_i     : in     std_logic;
      p2l_clk_n_i     : in     std_logic;
      p2l_data_i      : in     std_logic_vector(15 downto 0);
      p2l_dframe_i    : in     std_logic;
      p2l_valid_i     : in     std_logic;
      p2l_rdy_o       : out    std_logic;
      p_wr_req_i      : in     std_logic_vector(1 downto 0);
      p_wr_rdy_o      : out    std_logic_vector(1 downto 0);
      rx_error_o      : out    std_logic;
      vc_rdy_i        : in     std_logic_vector(1 downto 0);
      l2p_clk_p_o     : out    std_logic;
      l2p_clk_n_o     : out    std_logic;
      l2p_data_o      : out    std_logic_vector(15 downto 0);
      l2p_dframe_o    : out    std_logic;
      l2p_valid_o     : out    std_logic;
      l2p_edb_o       : out    std_logic;
      l2p_rdy_i       : in     std_logic;
      l_wr_rdy_i      : in     std_logic_vector(1 downto 0);
      p_rd_d_rdy_i    : in     std_logic_vector(1 downto 0);
      tx_error_i      : in     std_logic;
      dma_irq_o       : out    std_logic_vector(1 downto 0);
      irq_p_i         : in     std_logic;
      irq_p_o         : out    std_logic;
      dma_reg_clk_i   : in     std_logic;
      dma_reg_adr_i   : in     std_logic_vector(31 downto 0);
      dma_reg_dat_i   : in     std_logic_vector(31 downto 0);
      dma_reg_sel_i   : in     std_logic_vector(3 downto 0);
      dma_reg_stb_i   : in     std_logic;
      dma_reg_we_i    : in     std_logic;
      dma_reg_cyc_i   : in     std_logic;
      dma_reg_dat_o   : out    std_logic_vector(31 downto 0);
      dma_reg_ack_o   : out    std_logic;
      dma_reg_stall_o : out    std_logic;
      csr_clk_i       : in     std_logic;
      csr_adr_o       : out    std_logic_vector(31 downto 0);
      csr_dat_o       : out    std_logic_vector(31 downto 0);
      csr_sel_o       : out    std_logic_vector(3 downto 0);
      csr_stb_o       : out    std_logic;
      csr_we_o        : out    std_logic;
      csr_cyc_o       : out    std_logic;
      csr_dat_i       : in     std_logic_vector(31 downto 0);
      csr_ack_i       : in     std_logic;
      csr_stall_i     : in     std_logic;
      dma_clk_i       : in     std_logic;
      dma_adr_o       : out    std_logic_vector(31 downto 0);
      dma_dat_o       : out    std_logic_vector(31 downto 0);
      dma_sel_o       : out    std_logic_vector(3 downto 0);
      dma_stb_o       : out    std_logic;
      dma_we_o        : out    std_logic;
      dma_cyc_o       : out    std_logic;
      dma_dat_i       : in     std_logic_vector(31 downto 0);
      dma_ack_i       : in     std_logic;
      dma_stall_i     : in     std_logic);
  end component gn4124_core;

  component wr_gtp_phy_spartan6
    generic(
      g_simulation      : integer := 1;
      g_force_disparity : integer := 0;
      g_enable_ch0      : integer := 1;
      g_enable_ch1      : integer := 1);
    port (
      gtp_clk_i          : in     std_logic;
      ch0_ref_clk_i      : in     std_logic;
      ch0_tx_data_i      : in     std_logic_vector(7 downto 0);
      ch0_tx_k_i         : in     std_logic;
      ch0_tx_disparity_o : out    std_logic;
      ch0_tx_enc_err_o   : out    std_logic;
      ch0_rx_rbclk_o     : out    std_logic;
      ch0_rx_data_o      : out    std_logic_vector(7 downto 0);
      ch0_rx_k_o         : out    std_logic;
      ch0_rx_enc_err_o   : out    std_logic;
      ch0_rx_bitslide_o  : out    std_logic_vector(3 downto 0);
      ch0_rst_i          : in     std_logic;
      ch0_loopen_i       : in     std_logic;
      ch0_loopen_vec_i   : in     std_logic_vector(2 downto 0) := (others=>'0');
      ch0_tx_prbs_sel_i  : in     std_logic_vector(2 downto 0) := (others=>'0');
      ch0_rdy_o          : out    std_logic;
      ch1_ref_clk_i      : in     std_logic;
      ch1_tx_data_i      : in     std_logic_vector(7 downto 0) := "00000000";
      ch1_tx_k_i         : in     std_logic := '0';
      ch1_tx_disparity_o : out    std_logic;
      ch1_tx_enc_err_o   : out    std_logic;
      ch1_rx_data_o      : out    std_logic_vector(7 downto 0);
      ch1_rx_rbclk_o     : out    std_logic;
      ch1_rx_k_o         : out    std_logic;
      ch1_rx_enc_err_o   : out    std_logic;
      ch1_rx_bitslide_o  : out    std_logic_vector(3 downto 0);
      ch1_rst_i          : in     std_logic := '0';
      ch1_loopen_i       : in     std_logic := '0';
      ch1_loopen_vec_i   : in     std_logic_vector(2 downto 0) := (others=>'0');
      ch1_tx_prbs_sel_i  : in     std_logic_vector(2 downto 0) := (others=>'0');
      ch1_rdy_o          : out    std_logic;
      pad_txn0_o         : out    std_logic;
      pad_txp0_o         : out    std_logic;
      pad_rxn0_i         : in     std_logic := '0';
      pad_rxp0_i         : in     std_logic := '0';
      pad_txn1_o         : out    std_logic;
      pad_txp1_o         : out    std_logic;
      pad_rxn1_i         : in     std_logic := '0';
      pad_rxp1_i         : in     std_logic := '0');
  end component wr_gtp_phy_spartan6;

  component eb_slave_core
    generic(
      g_sdb_address    : std_logic_vector(63 downto 0);
      g_timeout_cycles : natural;
      g_mtu            : natural);
    port (
      clk_i       : in     std_logic;
      nRst_i      : in     std_logic;
      snk_i       : in     t_wrf_sink_in;
      snk_o       : out    t_wrf_sink_out;
      src_o       : out    t_wrf_source_out;
      src_i       : in     t_wrf_source_in;
      cfg_slave_o : out    t_wishbone_slave_out;
      cfg_slave_i : in     t_wishbone_slave_in;
      master_o    : out    t_wishbone_master_out;
      master_i    : in     t_wishbone_master_in);
  end component eb_slave_core;

begin
  dio_led_bot_o <= '0';
  dac_cs1_n_o <= dac_cs_n_o(0);
  dac_cs2_n_o <= dac_cs_n_o(1);
  dio_out(0) <= pps;
  slave_i(1) <= etherbone_wb_out;
  slave_i(0) <= genum_wb_out;
  etherbone_wb_in <= slave_o(1);
  genum_wb_in <= slave_o(0);
  master_i(0) <= wrc_slave_o;
  wrc_slave_i <= master_o(0);
  gen_dio_iobufs: for i in 0 to 4 generate
  begin

      U_obuf: OBUFDS
        generic map(
          CAPACITANCE => "DONT_CARE",
          IOSTANDARD  => "DEFAULT",
          SLEW        => "SLOW")
        port map(
          O  => dio_p_o(i),
          OB => dio_n_o(i),
          I  => dio_out(i));

      U_ibuf: IBUFDS
        generic map(
          CAPACITANCE      => "DONT_CARE",
          DIFF_TERM        => true,
          IBUF_DELAY_VALUE => "0",
          IBUF_LOW_PWR     => TRUE,
          IFD_DELAY_VALUE  => "AUTO",
          IOSTANDARD       => "DEFAULT",
          DQS_BIAS         => "FALSE")
        port map(
          O  => dio_in(i),
          I  => dio_p_i(i),
          IB => dio_n_i(i));
  end generate gen_dio_iobufs;

  U_WR_CORE: xwr_core
    generic map(
      g_simulation                => 0,
      g_phys_uart                 => true,
      g_virtual_uart              => true,
      g_with_external_clock_input => true,
      g_aux_clks                  => 0,
      g_ep_rxbuf_size             => 1024,
      g_tx_runt_padding           => true,
      g_dpram_initf               => "wrc.ram",
      g_dpram_size                => 131072/4,
      g_interface_mode            => PIPELINED,
      g_address_granularity       => BYTE,
      g_aux_sdb                   => c_etherbone_sdb,
      g_softpll_enable_debugger   => false,
      g_vuart_fifo_size           => 1024,
      g_pcs_16bit                 => false,
      g_ref_clock_rate            => 125000000,
      g_ext_clock_rate            => 10000000)
    port map(
      aux_master_i         => etherbone_cfg_out,
      aux_master_o         => etherbone_cfg_in,
      btn1_i               => button1_i,
      btn2_i               => button2_i,
      clk_aux_i            => (others => '0'),
      clk_dmtd_i           => clk_dmtd,
      clk_ext_i            => clk_ext,
      clk_ext_mul_i        => clk_ext_mul,
      clk_ext_mul_locked_i => clk_ext_mul_locked,
      clk_ref_i            => clk_125m_pllref,
      clk_sys_i            => clk_sys,
      dac_dpll_data_o      => dac_dpll_data,
      dac_dpll_load_p1_o   => dac_dpll_load_p1,
      dac_hpll_data_o      => dac_hpll_data,
      dac_hpll_load_p1_o   => dac_hpll_load_p1,
      dio_o                => open,
      fc_tx_pause_delay_i  => x"0000",
      fc_tx_pause_ready_o  => open,
      fc_tx_pause_req_i    => '0',
      led_act_o            => LED_RED,
      led_link_o           => LED_GREEN,
      link_ok_o            => open,
      owr_en_o             => owr_en,
      owr_i                => owr_i,
      owr_pwren_o          => open,
      phy_loopen_o         => phy_loopen,
      phy_loopen_vec_o     => phy_loopen_vec,
      phy_rdy_i            => phy_rdy,
      phy_ref_clk_i        => clk_125m_pllref,
      phy_rst_o            => phy_rst,
      phy_rx_bitslide_i    => phy_rx_bitslide,
      phy_rx_data_i        => phy_rx_data,
      phy_rx_enc_err_i     => phy_rx_enc_err,
      phy_rx_k_i           => phy_rx_k,
      phy_rx_rbclk_i       => phy_rx_rbclk,
      phy_sfp_los_i        => sfp_los_i,
      phy_sfp_tx_disable_o => sfp_tx_disable_o,
      phy_sfp_tx_fault_i   => sfp_tx_fault_i,
      phy_tx_data_o        => phy_tx_data,
      phy_tx_disparity_i   => phy_tx_disparity,
      phy_tx_enc_err_i     => phy_tx_enc_err,
      phy_tx_k_o           => phy_tx_k,
      phy_tx_prbs_sel_o    => phy_prbs_sel,
      pps_ext_i            => dio_in(3),
      pps_led_o            => pps_led,
      pps_p_o              => pps,
      rst_aux_n_o          => etherbone_rst_n,
      rst_n_i              => local_reset_n,
      rxts_o               => dio_out(1),
      scl_i                => wrc_scl_i,
      scl_o                => wrc_scl_o,
      sda_i                => wrc_sda_i,
      sda_o                => wrc_sda_o,
      sfp_det_i            => sfp_mod_def0_b,
      sfp_scl_i            => sfp_scl_i,
      sfp_scl_o            => sfp_scl_o,
      sfp_sda_i            => sfp_sda_i,
      sfp_sda_o            => sfp_sda_o,
      slave_i              => wrc_slave_i,
      slave_o              => wrc_slave_o,
      spi_miso_i           => spi_miso_i,
      spi_mosi_o           => spi_mosi_o,
      spi_ncs_o            => spi_ncs_o,
      spi_sclk_o           => spi_sclk_o,
      timestamps_ack_i     => '1',
      timestamps_o         => open,
      tm_clk_aux_lock_en_i => (others => '0'),
      tm_clk_aux_locked_o  => open,
      tm_cycles_o          => open,
      tm_dac_value_o       => open,
      tm_dac_wr_o          => open,
      tm_link_up_o         => open,
      tm_tai_o             => open,
      tm_time_valid_o      => open,
      txts_o               => dio_out(2),
      uart_rxd_i           => uart_rxd_i,
      uart_txd_o           => uart_txd_o,
      wrf_snk_i            => etherbone_src_out,
      wrf_snk_o            => etherbone_src_in,
      wrf_src_i            => etherbone_snk_out,
      wrf_src_o            => etherbone_snk_in);

  U_Reset_Gen: spec_reset_gen
    port map(
      clk_sys_i        => clk_sys,
      rst_pcie_n_a_i   => L_RST_N,
      rst_button_n_a_i => button1_i,
      rst_n_o          => local_reset_n);

  U_Ext_PLL: ext_pll_10_to_125m
    port map(
      clk_ext_i     => clk_ext,
      clk_ext_mul_o => clk_ext_mul,
      rst_a_i       => ext_pll_reset,
      locked_o      => clk_ext_mul_locked);

  U_input_buffer: IBUFGDS
    generic map(
      CAPACITANCE      => "DONT_CARE",
      DIFF_TERM        => TRUE,
      IBUF_DELAY_VALUE => "0",
      IBUF_LOW_PWR     => TRUE,
      IOSTANDARD       => "DEFAULT")
    port map(
      O  => clk_ext,
      I  => dio_clk_p_i,
      IB => dio_clk_n_i);

  U_Extend_EXT_Reset: gc_extend_pulse
    generic map(
      g_width => 1000)
    port map(
      clk_i      => clk_sys,
      rst_n_i    => local_reset_n,
      pulse_i    => local_reset,
      extended_o => ext_pll_reset);

  U_Extend_PPS: gc_extend_pulse
    generic map(
      g_width => 10000000)
    port map(
      clk_i      => clk_125m_pllref,
      rst_n_i    => local_reset_n,
      pulse_i    => pps_led,
      extended_o => dio_led_top_o);

  cmp_sys_clk_pll: PLL_BASE
    generic map(
      BANDWIDTH             => "OPTIMIZED",
      CLKFBOUT_MULT         => 8,
      CLKFBOUT_PHASE        => 0.000,
      CLKIN_PERIOD          => 8.0,
      CLKOUT0_DIVIDE        => 16,
      CLKOUT0_DUTY_CYCLE    => 0.500,
      CLKOUT0_PHASE         => 0.000,
      CLKOUT1_DIVIDE        => 16,
      CLKOUT1_DUTY_CYCLE    => 0.500,
      CLKOUT1_PHASE         => 0.000,
      CLKOUT2_DIVIDE        => 16,
      CLKOUT2_DUTY_CYCLE    => 0.500,
      CLKOUT2_PHASE         => 0.000,
      CLKOUT3_DIVIDE        => 1,
      CLKOUT3_DUTY_CYCLE    => 0.5,
      CLKOUT3_PHASE         => 0.0,
      CLKOUT4_DIVIDE        => 1,
      CLKOUT4_DUTY_CYCLE    => 0.5,
      CLKOUT4_PHASE         => 0.0,
      CLKOUT5_DIVIDE        => 1,
      CLKOUT5_DUTY_CYCLE    => 0.5,
      CLKOUT5_PHASE         => 0.0,
      CLK_FEEDBACK          => "CLKFBOUT",
      COMPENSATION          => "INTERNAL",
      DIVCLK_DIVIDE         => 1,
      REF_JITTER            => 0.016,
      RESET_ON_LOSS_OF_LOCK => FALSE)
    port map(
      CLKFBOUT => pllout_clk_fb_pllref,
      CLKOUT0  => pllout_clk_sys,
      CLKOUT1  => open,
      CLKOUT2  => open,
      CLKOUT3  => open,
      CLKOUT4  => open,
      CLKOUT5  => open,
      LOCKED   => open,
      CLKFBIN  => pllout_clk_fb_pllref,
      CLKIN    => clk_125m_pllref,
      RST      => '0');

  cmp_clk_sys_buf: BUFG
    port map(
      O => clk_sys,
      I => pllout_clk_sys);

  cmp_dmtd_clk_pll: PLL_BASE
    generic map(
      BANDWIDTH             => "OPTIMIZED",
      CLKFBOUT_MULT         => 50,
      CLKFBOUT_PHASE        => 0.000,
      CLKIN_PERIOD          => 50.0,
      CLKOUT0_DIVIDE        => 16,
      CLKOUT0_DUTY_CYCLE    => 0.500,
      CLKOUT0_PHASE         => 0.000,
      CLKOUT1_DIVIDE        => 16,
      CLKOUT1_DUTY_CYCLE    => 0.500,
      CLKOUT1_PHASE         => 0.000,
      CLKOUT2_DIVIDE        => 8,
      CLKOUT2_DUTY_CYCLE    => 0.500,
      CLKOUT2_PHASE         => 0.000,
      CLKOUT3_DIVIDE        => 1,
      CLKOUT3_DUTY_CYCLE    => 0.5,
      CLKOUT3_PHASE         => 0.0,
      CLKOUT4_DIVIDE        => 1,
      CLKOUT4_DUTY_CYCLE    => 0.5,
      CLKOUT4_PHASE         => 0.0,
      CLKOUT5_DIVIDE        => 1,
      CLKOUT5_DUTY_CYCLE    => 0.5,
      CLKOUT5_PHASE         => 0.0,
      CLK_FEEDBACK          => "CLKFBOUT",
      COMPENSATION          => "INTERNAL",
      DIVCLK_DIVIDE         => 1,
      REF_JITTER            => 0.016,
      RESET_ON_LOSS_OF_LOCK => FALSE)
    port map(
      CLKFBOUT => pllout_clk_fb_dmtd,
      CLKOUT0  => pllout_clk_dmtd,
      CLKOUT1  => open,
      CLKOUT2  => open,
      CLKOUT3  => open,
      CLKOUT4  => open,
      CLKOUT5  => open,
      LOCKED   => open,
      CLKFBIN  => pllout_clk_fb_dmtd,
      CLKIN    => clk_20m_vcxo_buf,
      RST      => '0');

  cmp_clk_dmtd_buf: BUFG
    port map(
      O => clk_dmtd,
      I => pllout_clk_dmtd);

  cmp_clk_vcxo: BUFG
    port map(
      O => clk_20m_vcxo_buf,
      I => clk_20m_vcxo_i);

  cmp_gtp_dedicated_clk_buf: IBUFGDS
    generic map(
      CAPACITANCE      => "DONT_CARE",
      DIFF_TERM        => TRUE,
      IBUF_DELAY_VALUE => "0",
      IBUF_LOW_PWR     => TRUE,
      IOSTANDARD       => "DEFAULT")
    port map(
      O  => gtp_dedicated_clk,
      I  => fpga_pll_ref_clk_101_p_i,
      IB => fpga_pll_ref_clk_101_n_i);

  U_DAC_ARB: spec_serial_dac_arb
    generic map(
      g_invert_sclk    => false,
      g_num_extra_bits => 8)
    port map(
      clk_i       => clk_sys,
      rst_n_i     => local_reset_n,
      val1_i      => dac_dpll_data,
      load1_i     => dac_dpll_load_p1,
      val2_i      => dac_hpll_data,
      load2_i     => dac_hpll_load_p1,
      dac_cs_n_o  => dac_cs_n_o,
      dac_clr_n_o => dac_clr_n_o,
      dac_sclk_o  => dac_sclk_o,
      dac_din_o   => dac_din_o);

  cmp_pllrefclk_buf: IBUFGDS
    generic map(
      CAPACITANCE      => "DONT_CARE",
      DIFF_TERM        => TRUE,
      IBUF_DELAY_VALUE => "0",
      IBUF_LOW_PWR     => TRUE,
      IOSTANDARD       => "DEFAULT")
    port map(
      O  => clk_125m_pllref,
      I  => clk_125m_pllref_p_i,
      IB => clk_125m_pllref_n_i);

  cmp_gn4124_core: gn4124_core
    port map(
      rst_n_a_i       => L_RST_N,
      status_o        => open,
      p2l_clk_p_i     => P2L_CLKp,
      p2l_clk_n_i     => P2L_CLKn,
      p2l_data_i      => P2L_DATA,
      p2l_dframe_i    => P2L_DFRAME,
      p2l_valid_i     => P2L_VALID,
      p2l_rdy_o       => P2L_RDY,
      p_wr_req_i      => P_WR_REQ,
      p_wr_rdy_o      => P_WR_RDY,
      rx_error_o      => RX_ERROR,
      vc_rdy_i        => VC_RDY,
      l2p_clk_p_o     => L2P_CLKp,
      l2p_clk_n_o     => L2P_CLKn,
      l2p_data_o      => L2P_DATA,
      l2p_dframe_o    => L2P_DFRAME,
      l2p_valid_o     => L2P_VALID,
      l2p_edb_o       => L2P_EDB,
      l2p_rdy_i       => L2P_RDY,
      l_wr_rdy_i      => L_WR_RDY,
      p_rd_d_rdy_i    => P_RD_D_RDY,
      tx_error_i      => TX_ERROR,
      dma_irq_o       => open,
      irq_p_i         => '0',
      irq_p_o         => GPIO(0),
      dma_reg_clk_i   => clk_sys,
      dma_reg_adr_i   => dma_reg_adr_i,
      dma_reg_dat_i   => dma_reg_dat_i,
      dma_reg_sel_i   => dma_reg_sel_i,
      dma_reg_stb_i   => dma_reg_stb_i,
      dma_reg_we_i    => dma_reg_we_i,
      dma_reg_cyc_i   => dma_reg_cyc_i,
      dma_reg_dat_o   => dma_reg_dat_o,
      dma_reg_ack_o   => dma_reg_ack_o,
      dma_reg_stall_o => dma_reg_stall_o,
      csr_clk_i       => clk_sys,
      csr_adr_o       => wb_adr,
      csr_dat_o       => csr_dat_o,
      csr_sel_o       => csr_sel_o,
      csr_stb_o       => csr_stb_o,
      csr_we_o        => csr_we_o,
      csr_cyc_o       => csr_cyc_o,
      csr_dat_i       => csr_dat_i,
      csr_ack_i       => genum_csr_ack_i,
      csr_stall_i     => csr_stall_i,
      dma_clk_i       => clk_sys,
      dma_adr_o       => dma_adr_o,
      dma_dat_o       => dma_dat_o,
      dma_sel_o       => dma_sel_o,
      dma_stb_o       => dma_stb_o,
      dma_we_o        => dma_we_o,
      dma_cyc_o       => dma_cyc_o,
      dma_dat_i       => dma_dat_i,
      dma_ack_i       => dma_ack_i,
      dma_stall_i     => dma_stall_i);

  U_GTP: wr_gtp_phy_spartan6
    generic map(
      g_simulation      => 0,
      g_force_disparity => 0,
      g_enable_ch0      => 0,
      g_enable_ch1      => 1)
    port map(
      gtp_clk_i          => gtp_dedicated_clk,
      ch0_ref_clk_i      => clk_125m_pllref,
      ch0_tx_data_i      => x"00",
      ch0_tx_k_i         => '0',
      ch0_tx_disparity_o => open,
      ch0_tx_enc_err_o   => open,
      ch0_rx_rbclk_o     => open,
      ch0_rx_data_o      => open,
      ch0_rx_k_o         => open,
      ch0_rx_enc_err_o   => open,
      ch0_rx_bitslide_o  => open,
      ch0_rst_i          => '1',
      ch0_loopen_i       => '0',
      ch0_loopen_vec_i   => "000",
      ch0_tx_prbs_sel_i  => "000",
      ch0_rdy_o          => open,
      ch1_ref_clk_i      => clk_125m_pllref,
      ch1_tx_data_i      => phy_tx_data,
      ch1_tx_k_i         => phy_tx_k(0),
      ch1_tx_disparity_o => phy_tx_disparity,
      ch1_tx_enc_err_o   => phy_tx_enc_err,
      ch1_rx_data_o      => phy_rx_data,
      ch1_rx_rbclk_o     => phy_rx_rbclk,
      ch1_rx_k_o         => phy_rx_k(0),
      ch1_rx_enc_err_o   => phy_rx_enc_err,
      ch1_rx_bitslide_o  => phy_rx_bitslide,
      ch1_rst_i          => phy_rst,
      ch1_loopen_i       => phy_loopen,
      ch1_loopen_vec_i   => phy_loopen_vec,
      ch1_tx_prbs_sel_i  => phy_prbs_sel,
      ch1_rdy_o          => phy_rdy,
      pad_txn0_o         => open,
      pad_txp0_o         => open,
      pad_rxn0_i         => '0',
      pad_rxp0_i         => '0',
      pad_txn1_o         => sfp_txn_o,
      pad_txp1_o         => sfp_txp_o,
      pad_rxn1_i         => sfp_rxn_i,
      pad_rxp1_i         => sfp_rxp_i);

  Etherbone: eb_slave_core
    generic map(
      g_sdb_address    => x"0000000000030000",
      g_timeout_cycles => 6250000,
      g_mtu            => 1500)
    port map(
      clk_i       => clk_sys,
      nRst_i      => etherbone_rst_n,
      snk_i       => etherbone_snk_in,
      snk_o       => etherbone_snk_out,
      src_o       => etherbone_src_out,
      src_i       => etherbone_src_in,
      cfg_slave_o => etherbone_cfg_out,
      cfg_slave_i => etherbone_cfg_in,
      master_o    => etherbone_wb_out,
      master_i    => etherbone_wb_in);

  masterbar: xwb_crossbar
    generic map(
      g_num_masters => 2,
      g_num_slaves  => 1,
      g_registered  => false,
      g_address     => (0 => x"00000000"),
      g_mask        => (0 => x"00000000"))
    port map(
      clk_sys_i => clk_sys,
      rst_n_i   => local_reset_n,
      slave_i   => slave_i,
      slave_o   => slave_o,
      master_i  => master_i,
      master_o  => master_o);

  cmp_l_clk_buf: IBUFDS
    generic map(
      CAPACITANCE      => "DONT_CARE",
      DIFF_TERM        => false,
      IBUF_DELAY_VALUE => "0",
      IBUF_LOW_PWR     => true,
      IFD_DELAY_VALUE  => "AUTO",
      IOSTANDARD       => "DEFAULT",
      DQS_BIAS         => "FALSE")
    port map(
      O  => l_clk,
      I  => L_CLKp,
      IB => L_CLKn);
  local_reset <= not local_reset_n;

    fpga_scl_b <= '0' when wrc_scl_o = '0' else 'Z';
    fpga_sda_b <= '0' when wrc_sda_o = '0' else 'Z';
    wrc_scl_i  <= fpga_scl_b;
    wrc_sda_i  <= fpga_sda_b;


    sfp_mod_def1_b <= '0' when sfp_scl_o = '0' else 'Z';
    sfp_mod_def2_b <= '0' when sfp_sda_o = '0' else 'Z';
    sfp_scl_i      <= sfp_mod_def1_b;
    sfp_sda_i      <= sfp_mod_def2_b;


    thermo_id <= '0' when owr_en(0) = '1' else 'Z';
    owr_i(0)  <= thermo_id;

    dio_onewire_b <= '0' when owr_en(1) = '1' else 'Z';
    owr_i(1)      <= dio_onewire_b;
    dio_oe_n_o(0)          <= '0';
    dio_oe_n_o(2 downto 1) <= (others => '0');
    dio_oe_n_o(3)          <= '1';        -- for external 1-PPS
    dio_oe_n_o(4)          <= '1';        -- for external 10MHz clock

    dio_term_en_o <= (others => '0');

    dio_sdn_ck_n_o <= '1';
    dio_sdn_n_o    <= '1';

  --  sfp_tx_disable_o <= '0';
    ------------------------------------------------------------------------------
    -- Active high reset
    ------------------------------------------------------------------------------
    rst <= not(L_RST_N);
        genum_wb_out.adr(1  downto  0) <= (others => '0');
        genum_wb_out.adr(18 downto  2) <= wb_adr(16 downto 0);
        genum_wb_out.adr(31 downto 19) <= (others => '0');
        genum_wb_out.dat               <= csr_dat_o;
        genum_wb_out.sel               <= csr_sel_o;
        genum_wb_out.stb               <= csr_stb_o;
        genum_wb_out.we                <= csr_we_o;
        genum_wb_out.cyc               <= csr_cyc_o;
        csr_dat_i                      <= genum_wb_in.dat;
        genum_csr_ack_i                <= genum_wb_in.ack or genum_wb_in.err;
        csr_stall_i                    <= genum_wb_in.stall;
  --      csr_err_i         <= ;
  --      csr_rty_i         <= ;
  --      csr_int_i         <= ;
    dma_reg_adr_i <= x"00000000";
    dma_reg_dat_i <= x"00000000";
    dma_reg_sel_i <= x"0";
    dma_reg_stb_i <= '0';
    dma_reg_we_i  <= '0';
    dma_reg_cyc_i <= '0';
    --dma_reg_dat_o   => dma_reg_dat_i,
    --dma_reg_ack_o   => dma_reg_ack,
    --dma_reg_stall_o => dma_reg_stall
    --dma_adr_o   => dma_adr,
    --dma_dat_o   => dma_dat_o,
    --dma_sel_o   => dma_sel,
    --dma_stb_o   => dma_stb,
    --dma_we_o    => dma_we,
    --dma_cyc_o   => dma_cyc,
    dma_dat_i   <= x"00000000";
    dma_ack_i   <= '0';
    dma_stall_i <= '0';

  pr1: process (clk_sys, rst) is		-- EASE/HDL sens.list
  begin
      if rising_edge(clk_sys) then
        led_divider <= led_divider + 1;
      end if;
  end process pr1 ;
end architecture rtl ; -- of spec_top

--------------------------------------------------------------------------------
-- Object        : Entity work.spec_top_tb
-- Last modified : Wed Aug 26 15:09:53 2015.
--------------------------------------------------------------------------------



library ieee, unisim;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use unisim.VCOMPONENTS.ALL;

entity spec_top_tb is
  generic(
    g_simulation            : integer := 0;
    g_lm32_wrpc_dpram_size  : integer := 131072/4;
    g_date_id               : integer := 0;
    g_revision_id           : integer := 0;
    g_lm32_wrpc_dpram_initf : string := "");
  port (
    Rx_Fire          : in     std_logic;
    button1_i        : in     std_logic;
    button2_i        : in     std_logic := 'H';
    clk_20m_vcxo_p_i : in     std_logic;
    dio_onewire_b    : inout  std_logic;
    fpga_scl_b       : inout  std_logic;
    fpga_sda_b       : inout  std_logic;
    sfp_mod_def1_b   : inout  std_logic;
    sfp_mod_def2_b   : inout  std_logic;
    thermo_id        : inout  std_logic);
end entity spec_top_tb;

--------------------------------------------------------------------------------
-- Object        : Architecture work.spec_top_tb.structure
-- Last modified : Wed Aug 26 15:09:53 2015.
--------------------------------------------------------------------------------

architecture structure of spec_top_tb is

  signal MGTCLK_N     : std_logic;
  signal MGTCLK_P     : std_logic;
  signal RESET        : std_logic;
  signal TxData       : std_logic_vector(15 downto 0);
  signal pad_txn_o    : std_logic;
  signal pad_txp_o    : std_logic;
  signal sfp_txn_o    : std_logic;
  signal sfp_txp_o    : std_logic;
  signal tx_out_clk_o : std_logic;
  signal O            : std_ulogic;
  signal TxCharIsK    : std_logic_vector(1 downto 0);

  component wr_gtx_phy_kintex7
    generic(
      g_simulation : integer := 0);
    port (
      clk_gtx_i      : in     std_logic;
      tx_data_i      : in     std_logic_vector(15 downto 0);
      tx_k_i         : in     std_logic_vector(1 downto 0);
      tx_disparity_o : out    std_logic;
      tx_enc_err_o   : out    std_logic;
      rx_rbclk_o     : out    std_logic;
      rx_data_o      : out    std_logic_vector(15 downto 0);
      rx_k_o         : out    std_logic_vector(1 downto 0);
      rx_enc_err_o   : out    std_logic;
      rx_bitslide_o  : out    std_logic_vector(4 downto 0);
      rst_i          : in     std_logic;
      loopen_i       : in     std_logic_vector(2 downto 0);
      pad_txn_o      : out    std_logic;
      pad_txp_o      : out    std_logic;
      pad_rxn_i      : in     std_logic := '0';
      pad_rxp_i      : in     std_logic := '0';
      tx_out_clk_o   : out    std_logic;
      tx_locked_o    : out    std_logic;
      tx_prbs_sel_i  : in     std_logic_vector(2 downto 0);
      rdy_o          : out    std_logic);
  end component wr_gtx_phy_kintex7;

  component TransmitFrame16bit
    generic(
      tx_data_swap : boolean := false);
    port (
      CRCOut     : out    std_logic_vector(31 downto 0);
      Clk        : in     std_logic;
      Rst        : in     std_logic;
      Rx_CRC_Err : in     std_logic;
      Rx_Fire    : in     std_logic;
      TxCharIsK  : out    std_logic_vector(1 downto 0);
      TxData     : out    std_logic_vector(15 downto 0));
  end component TransmitFrame16bit;

  component ClkRstGen
    port (
      MGTCLK_N : out    std_logic;
      MGTCLK_P : out    std_logic;
      RESET    : out    std_logic;
      SysClk_n : out    std_logic;
      SysClk_p : out    std_logic);
  end component ClkRstGen;

  component spec_top
    port (
      GPIO                     : inout  std_logic_vector(1 downto 0);
      L2P_CLKn                 : out    std_logic;
      L2P_CLKp                 : out    std_logic;
      L2P_DATA                 : out    std_logic_vector(15 downto 0);
      L2P_DFRAME               : out    std_logic;
      L2P_EDB                  : out    std_logic;
      L2P_RDY                  : in     std_logic;
      L2P_VALID                : out    std_logic;
      LED_GREEN                : out    std_logic;
      LED_RED                  : out    std_logic;
      L_CLKn                   : in     std_logic;
      L_CLKp                   : in     std_logic;
      L_RST_N                  : in     std_logic;
      L_WR_RDY                 : in     std_logic_vector(1 downto 0);
      P2L_CLKn                 : in     std_logic;
      P2L_CLKp                 : in     std_logic;
      P2L_DATA                 : in     std_logic_vector(15 downto 0);
      P2L_DFRAME               : in     std_logic;
      P2L_RDY                  : out    std_logic;
      P2L_VALID                : in     std_logic;
      P_RD_D_RDY               : in     std_logic_vector(1 downto 0);
      P_WR_RDY                 : out    std_logic_vector(1 downto 0);
      P_WR_REQ                 : in     std_logic_vector(1 downto 0);
      RX_ERROR                 : out    std_logic;
      TX_ERROR                 : in     std_logic;
      VC_RDY                   : in     std_logic_vector(1 downto 0);
      button1_i                : in     std_logic := 'H';
      button2_i                : in     std_logic := 'H';
      clk_125m_pllref_n_i      : in     std_logic;
      clk_125m_pllref_p_i      : in     std_logic;
      clk_20m_vcxo_i           : in     std_logic;
      dac_clr_n_o              : out    std_logic;
      dac_cs1_n_o              : out    std_logic;
      dac_cs2_n_o              : out    std_logic;
      dac_din_o                : out    std_logic;
      dac_sclk_o               : out    std_logic;
      dio_clk_n_i              : in     std_logic;
      dio_clk_p_i              : in     std_logic;
      dio_led_bot_o            : out    std_logic;
      dio_led_top_o            : out    std_logic;
      dio_n_i                  : in     std_logic_vector(4 downto 0);
      dio_n_o                  : out    std_logic_vector(4 downto 0);
      dio_oe_n_o               : out    std_logic_vector(4 downto 0);
      dio_onewire_b            : inout  std_logic;
      dio_p_i                  : in     std_logic_vector(4 downto 0);
      dio_p_o                  : out    std_logic_vector(4 downto 0);
      dio_sdn_ck_n_o           : out    std_logic;
      dio_sdn_n_o              : out    std_logic;
      dio_term_en_o            : out    std_logic_vector(4 downto 0);
      fpga_pll_ref_clk_101_n_i : in     std_logic;
      fpga_pll_ref_clk_101_p_i : in     std_logic;
      fpga_scl_b               : inout  std_logic;
      fpga_sda_b               : inout  std_logic;
      sfp_los_i                : in     std_logic;
      sfp_mod_def0_b           : in     std_logic;
      sfp_mod_def1_b           : inout  std_logic;
      sfp_mod_def2_b           : inout  std_logic;
      sfp_rate_select_b        : inout  std_logic;
      sfp_rxn_i                : in     std_logic;
      sfp_rxp_i                : in     std_logic;
      sfp_tx_disable_o         : out    std_logic;
      sfp_tx_fault_i           : in     std_logic;
      sfp_txn_o                : out    std_logic;
      sfp_txp_o                : out    std_logic;
      spi_miso_i               : in     std_logic := 'L';
      spi_mosi_o               : out    std_logic;
      spi_ncs_o                : out    std_logic;
      spi_sclk_o               : out    std_logic;
      thermo_id                : inout  std_logic;
      uart_rxd_i               : in     std_logic;
      uart_txd_o               : out    std_logic);
  end component spec_top;

  component pullup1
    port (
      o1 : out    std_logic;
      o2 : out    std_logic);
  end component pullup1;

begin

  u1: wr_gtx_phy_kintex7
    generic map(
      g_simulation => g_simulation)
    port map(
      clk_gtx_i      => O,
      tx_data_i      => TxData,
      tx_k_i         => TxCharIsK,
      tx_disparity_o => open,
      tx_enc_err_o   => open,
      rx_rbclk_o     => open,
      rx_data_o      => open,
      rx_k_o         => open,
      rx_enc_err_o   => open,
      rx_bitslide_o  => open,
      rst_i          => RESET,
      loopen_i       => "000",
      pad_txn_o      => pad_txn_o,
      pad_txp_o      => pad_txp_o,
      pad_rxn_i      => sfp_txn_o,
      pad_rxp_i      => sfp_txp_o,
      tx_out_clk_o   => tx_out_clk_o,
      tx_locked_o    => open,
      tx_prbs_sel_i  => "000",
      rdy_o          => open);

  u2: TransmitFrame16bit
    generic map(
      tx_data_swap => true)
    port map(
      CRCOut     => open,
      Clk        => tx_out_clk_o,
      Rst        => RESET,
      Rx_CRC_Err => '0',
      Rx_Fire    => Rx_Fire,
      TxCharIsK  => TxCharIsK,
      TxData     => TxData);

  u3: ClkRstGen
    port map(
      MGTCLK_N => MGTCLK_N,
      MGTCLK_P => MGTCLK_P,
      RESET    => RESET,
      SysClk_n => open,
      SysClk_p => open);

  u4: IBUFDS
    generic map(
      CAPACITANCE      => "DONT_CARE",
      DIFF_TERM        => FALSE,
      IBUF_DELAY_VALUE => "0",
      IBUF_LOW_PWR     => TRUE,
      IFD_DELAY_VALUE  => "AUTO",
      IOSTANDARD       => "DEFAULT",
      DQS_BIAS         => "FALSE")
    port map(
      O  => O,
      I  => MGTCLK_P,
      IB => MGTCLK_N);

  u5: spec_top
    port map(
      GPIO                     => open,
      L2P_CLKn                 => open,
      L2P_CLKp                 => open,
      L2P_DATA                 => open,
      L2P_DFRAME               => open,
      L2P_EDB                  => open,
      L2P_RDY                  => '0',
      L2P_VALID                => open,
      LED_GREEN                => open,
      LED_RED                  => open,
      L_CLKn                   => '0',
      L_CLKp                   => '1',
      L_RST_N                  => '1',
      L_WR_RDY                 => "00",
      P2L_CLKn                 => '0',
      P2L_CLKp                 => '1',
      P2L_DATA                 => x"0000",
      P2L_DFRAME               => '0',
      P2L_RDY                  => open,
      P2L_VALID                => '0',
      P_RD_D_RDY               => "00",
      P_WR_RDY                 => open,
      P_WR_REQ                 => "00",
      RX_ERROR                 => open,
      TX_ERROR                 => '0',
      VC_RDY                   => "00",
      button1_i                => button1_i,
      button2_i                => button2_i,
      clk_125m_pllref_n_i      => MGTCLK_P,
      clk_125m_pllref_p_i      => MGTCLK_N,
      clk_20m_vcxo_i           => clk_20m_vcxo_p_i,
      dac_clr_n_o              => open,
      dac_cs1_n_o              => open,
      dac_cs2_n_o              => open,
      dac_din_o                => open,
      dac_sclk_o               => open,
      dio_clk_n_i              => '1',
      dio_clk_p_i              => '0',
      dio_led_bot_o            => open,
      dio_led_top_o            => open,
      dio_n_i                  => "11111",
      dio_n_o                  => open,
      dio_oe_n_o               => open,
      dio_onewire_b            => dio_onewire_b,
      dio_p_i                  => "00000",
      dio_p_o                  => open,
      dio_sdn_ck_n_o           => open,
      dio_sdn_n_o              => open,
      dio_term_en_o            => open,
      fpga_pll_ref_clk_101_n_i => MGTCLK_P,
      fpga_pll_ref_clk_101_p_i => MGTCLK_N,
      fpga_scl_b               => fpga_scl_b,
      fpga_sda_b               => fpga_sda_b,
      sfp_los_i                => '0',
      sfp_mod_def0_b           => '1',
      sfp_mod_def1_b           => sfp_mod_def1_b,
      sfp_mod_def2_b           => sfp_mod_def2_b,
      sfp_rate_select_b        => open,
      sfp_rxn_i                => pad_txn_o,
      sfp_rxp_i                => pad_txp_o,
      sfp_tx_disable_o         => open,
      sfp_tx_fault_i           => '0',
      sfp_txn_o                => sfp_txn_o,
      sfp_txp_o                => sfp_txp_o,
      spi_miso_i               => '0',
      spi_mosi_o               => open,
      spi_ncs_o                => open,
      spi_sclk_o               => open,
      thermo_id                => thermo_id,
      uart_rxd_i               => '1',
      uart_txd_o               => open);

  u0: pullup1
    port map(
      o1 => fpga_sda_b,
      o2 => fpga_scl_b);

  u6: pullup1
    port map(
      o1 => sfp_mod_def2_b,
      o2 => sfp_mod_def1_b);

  u7: pullup1
    port map(
      o1 => dio_onewire_b,
      o2 => thermo_id);
end architecture structure ; -- of spec_top_tb

