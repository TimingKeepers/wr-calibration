--------------------------------------------------------------------------------
--
-- This VHDL file was generated by EASE/HDL 8.3 Revision 5 from HDL Works B.V.
--
-- Ease library  : design
-- HDL library   : work
-- Host name     : SERING
-- User name     : peterj
-- Time stamp    : Fri Nov 04 12:07:03 2016
--
-- Designed by   : 
-- Company       : 
-- Project info  : 
--
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Object        : Entity design.USB_FanOut
-- Last modified : Wed Mar 11 13:38:26 2015
--------------------------------------------------------------------------------



library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity USB_FanOut is
  port (
    Rx1        : out    std_logic;
    Rx2        : out    std_logic;
    Tx1        : in     std_logic;
    Tx2        : in     std_logic;
    USBEXT_RX1 : in     std_logic;
    USBEXT_RX2 : in     std_logic;
    USBEXT_TX1 : out    std_logic;
    USBEXT_TX2 : out    std_logic;
    USB_RX1    : in     std_logic;
    USB_RX2    : in     std_logic;
    USB_TX1    : out    std_logic;
    USB_TX2    : out    std_logic);
end entity USB_FanOut;

--------------------------------------------------------------------------------
-- Object        : Architecture design.USB_FanOut.structure
-- Last modified : Wed Mar 11 13:38:26 2015
--------------------------------------------------------------------------------


architecture structure of USB_FanOut is

begin

USB_TX1    <= Tx1;
USBEXT_TX1 <= Tx1;
Rx1        <= USB_RX1 Or USBEXT_RX1;

USB_TX2    <= Tx2;
USBEXT_TX2 <= Tx2;
Rx2        <= USB_RX2 Or USBEXT_RX2;

end architecture structure ; -- of USB_FanOut

--------------------------------------------------------------------------------
-- Object        : Entity design.OrGate
-- Last modified : Fri Feb 28 11:06:17 2014
--------------------------------------------------------------------------------



library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity OrGate is
  port (
    A : in     std_logic;
    B : in     std_logic;
    O : out    std_logic);
end entity OrGate;

--------------------------------------------------------------------------------
-- Object        : Architecture design.OrGate.rtl
-- Last modified : Fri Feb 28 11:06:17 2014
--------------------------------------------------------------------------------


architecture rtl of OrGate is

begin
   O <= A Or B;
end architecture rtl ; -- of OrGate

--------------------------------------------------------------------------------
-- Object        : Entity design.RepeatFire
-- Last modified : Fri Aug 01 10:47:19 2014
--------------------------------------------------------------------------------



library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity RepeatFire is
  port (
    Clk       : in     std_logic;
    Enable    : in     std_logic;
    Fire      : out    std_logic;
    Rst       : in     std_logic;
    div_ratio : in     std_logic_vector(31 downto 0));
end entity RepeatFire;

--------------------------------------------------------------------------------
-- Object        : Architecture design.RepeatFire.rtl
-- Last modified : Fri Aug 01 10:47:19 2014
--------------------------------------------------------------------------------


architecture rtl of RepeatFire is

begin
   process (Clk, Rst)
      Variable Cnt: Unsigned(31 downto 0);
   begin
      if Rst = '1' then
	     Fire <= '0';
		 Cnt := (others => '0');
	  elsif rising_edge(Clk) then
		 if Cnt >= to_integer(unsigned(div_ratio)) then
		    Cnt := (others => '0');
			Fire <= Enable;
		 else
            Cnt := Cnt + 1;
			Fire <= '0';
         end if;
	  end if;
   end process;
end architecture rtl ; -- of RepeatFire

--------------------------------------------------------------------------------
-- Object        : Entity design.Debounce
-- Last modified : Thu Aug 07 10:47:08 2014
--------------------------------------------------------------------------------



library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity Debounce is
  generic(
    g_simulation : integer := 0);
  port (
    Clk   : in     std_logic;
    I     : in     std_logic;
    O     : out    std_logic;
    Pulse : out    std_logic;
    Rst   : in     std_logic);
end entity Debounce;

--------------------------------------------------------------------------------
-- Object        : Architecture design.Debounce.rtl
-- Last modified : Thu Aug 07 10:47:08 2014
--------------------------------------------------------------------------------


architecture rtl of Debounce is
   signal tc     : std_logic;
   signal tc_del : std_logic;
begin
   Process (Clk, Rst)
      Variable Meta_1, Meta_2, TerminalCount: Std_Logic;
      Variable Cnt: Unsigned (23 downto 0);  -- 2^23 = 8388608 * 16 ns = 0,134 sec debounce time
   Begin
      If Rst = '1' Then
         Meta_1 := '0';
         Meta_2 := '0';
         Cnt := (Others => '0');
         TerminalCount := '0';
         tc <= '0';
      ElsIf Rising_Edge(Clk) Then
         Meta_2 := Meta_1;
         Meta_1 := I;

         If Meta_2 = '1' Then
            If g_simulation = 1 Then
               TerminalCount := Cnt(Cnt'Right);
            Else
               TerminalCount := Cnt(Cnt'Left);
            End If;
            
            If TerminalCount = '1' Then
               tc <= '1';
            Else
               Cnt := Cnt + 1;
               tc <= '0';
            End If;
         Else
            Cnt := (Others => '0');
            tc <= '0';
         End If;
      End If;
   End Process;
   
   Process (Clk, Rst)
   Begin
      If Rst = '1' Then
         tc_del <= '0';
      ElsIf Rising_Edge(Clk) Then
         tc_del <= tc;
      End If;
   End Process;

   O <= tc;                     -- Straight debounched output
   Pulse <= not tc_del and tc;  -- One clock tick output
   
end architecture rtl ; -- of Debounce

--------------------------------------------------------------------------------
-- Object        : Entity design.ActivityLEDs
-- Last modified : Wed Feb 25 11:36:05 2015
--------------------------------------------------------------------------------



library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity ActivityLEDs is
  port (
    ActLED  : out    std_logic_vector(3 downto 0);
    Clk     : in     std_logic;
    I       : in     std_logic_vector(3 downto 0);
    Rst     : in     std_logic;
    mnic_wr : in     std_logic);
end entity ActivityLEDs;

--------------------------------------------------------------------------------
-- Object        : Architecture design.ActivityLEDs.rtl
-- Last modified : Wed Feb 25 11:36:05 2015
--------------------------------------------------------------------------------


architecture rtl of ActivityLEDs is

begin
   Process (Clk, Rst)
   Begin
      If Rst = '1' Then
	     ActLED <= (others => '0');
	  ElsIf Rising_Edge(Clk) Then
--	     For n in 0 to 3 loop
	    For n in 0 to 2 loop
		    If I(n) = '0' Then
			    ActLed(n) <= '1';
        End If;
      End Loop;
  
      If mnic_wr = '1' Then
			  ActLed(3) <= '1';
			End If;

     End If;
   End Process;
end architecture rtl ; -- of ActivityLEDs

--------------------------------------------------------------------------------
-- Object        : Entity design.DummyTx
-- Last modified : Wed Feb 25 11:43:57 2015
--------------------------------------------------------------------------------



library ieee, work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.EMAC16bit_Package.all;

entity DummyTx is
  port (
    UDP_Tx : out    dbus_type_array(NUM_UDP_PRTS-2 downto 0);
    WrReqi : out    std_logic_vector(NUM_UDP_PRTS-2 downto 0));
end entity DummyTx;

--------------------------------------------------------------------------------
-- Object        : Architecture design.DummyTx.rtl
-- Last modified : Wed Feb 25 11:43:57 2015
--------------------------------------------------------------------------------


architecture rtl of DummyTx is

begin
     GEN_DummyTx: for i in 0 to NUM_UDP_PRTS-2 generate 
       WrReqi(i) <= '0';
       UDP_TX(i).D <= (Others => '0');
       UDP_TX(i).EOD <= '0';
     end generate;
end architecture rtl ; -- of DummyTx

--------------------------------------------------------------------------------
-- Object        : Entity design.FirePacketGen
-- Last modified : Mon Mar 10 10:09:28 2014
--------------------------------------------------------------------------------



library ieee, work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.EMAC16bit_Package.all;

entity FirePacketGen is
  port (
    Clk        : in     std_logic;
    Full       : in     std_logic;
    Rst        : in     std_logic;
    Tx_Fire    : in     std_logic;
    UDP_Tx     : out    dbus_type;
    WrReq      : out    std_logic;
    numpackets : in     std_logic_vector(9 downto 0);
    numwords   : in     std_logic_vector(13 downto 0));
end entity FirePacketGen;

--------------------------------------------------------------------------------
-- Object        : Architecture design.FirePacketGen.fsm
-- Last modified : Mon Mar 10 10:09:28 2014
--------------------------------------------------------------------------------

architecture fsm of FirePacketGen is

  -- State Machine Options:
  --  Clock : Clk (Rising edge).
  --  State assignment : Enumerate.
  --  State decoding : Case construct.
  --  Actions on transitions : Clocked.
  --  Actions on states : Clocked.

  type state_type is (Idle, Packet) ;
  signal state : state_type ;  -- Current State


begin

  state_decoding: process (Clk, Rst) is
      Variable Cnt: Integer Range 0 to 16383;
      Variable Frame: Integer Range 0 to 1023;


  begin
    if (Rst = '1') then
      state <= Idle ;
      -- Initalize:
      UDP_Tx.EOD <= '0';
      UDP_Tx.D <= x"aa11";
      WrReq <= '0';
      Cnt := 0;
      Frame := 0;
    elsif (rising_edge(Clk)) then
      lbl_state : case state is
        when Idle =>
          if (Tx_Fire = '1') then
            state <= Packet ;
            Cnt := 0;
            Frame := 1;
            If Full = '0' Then
               Cnt := Cnt + 1;
            End If;
            If Cnt = to_integer(unsigned (numwords)) Then
               UDP_Tx.EOD <= '1';
               UDP_Tx.D <= x"0E0D";
            ElsIf Cnt = 1 Then
               UDP_Tx.EOD <= '0';
               UDP_Tx.D <= x"050D";
            Else
               UDP_Tx.EOD <= '0';
               UDP_Tx.D <= Std_Logic_Vector(To_Unsigned(Cnt,16));
            End If;
            WrReq <= Not Full;
          else
            state <= Idle ;
            UDP_Tx.EOD <= '0';
            UDP_Tx.D <= x"aa11";
            WrReq <= '0';
          end if ;
        when Packet =>
          if (Full = '0' And Cnt=to_integer(unsigned (numwords)) And Frame = to_integer(unsigned (numpackets))) then
            state <= Idle ;
            UDP_Tx.EOD <= '0';
            UDP_Tx.D <= x"aa11";
            WrReq <= '0';
          elsif (
            Full = '0' And Cnt = to_integer(unsigned (numwords))

            ) then
            state <= Packet ;
            Cnt := 0;
            Frame := Frame + 1;
            If Full = '0' Then
               Cnt := Cnt + 1;
            End If;
            If Cnt = to_integer(unsigned (numwords)) Then
               UDP_Tx.EOD <= '1';
               UDP_Tx.D <= x"0E0D";
            ElsIf Cnt = 1 Then
               UDP_Tx.EOD <= '0';
               UDP_Tx.D <= x"050D";
            Else
               UDP_Tx.EOD <= '0';
               UDP_Tx.D <= Std_Logic_Vector(To_Unsigned(Cnt,16));
            End If;
            WrReq <= Not Full;
          else
            state <= Packet ;
            If Full = '0' Then
               Cnt := Cnt + 1;
            End If;
            If Cnt = to_integer(unsigned (numwords)) Then
               UDP_Tx.EOD <= '1';
               UDP_Tx.D <= x"0E0D";
            ElsIf Cnt = 1 Then
               UDP_Tx.EOD <= '0';
               UDP_Tx.D <= x"050D";
            Else
               UDP_Tx.EOD <= '0';
               UDP_Tx.D <= Std_Logic_Vector(To_Unsigned(Cnt,16));
            End If;
            WrReq <= Not Full;
          end if ;
      end case lbl_state ;
    end if ; --  Reset & Clock
  end process state_decoding ;

end architecture fsm ; -- of FirePacketGen

--------------------------------------------------------------------------------
-- Object        : Entity design.FirePackets
-- Last modified : Wed Feb 25 12:28:07 2015
--------------------------------------------------------------------------------



library ieee, work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.EMAC16bit_Package.all;

entity FirePackets is
  generic(
    g_simulation : integer := 0);
  port (
    Clk             : in     std_logic;
    Fire            : in     std_logic;
    Rst             : in     std_logic;
    UDP_Tx          : out    dbus_type;
    UDP_Tx_Full     : in     std_logic;
    UDP_Tx_WrReq    : out    std_logic;
    udp_tstgen_cont : in     std_logic);
end entity FirePackets;

--------------------------------------------------------------------------------
-- Object        : Architecture design.FirePackets.a0
-- Last modified : Wed Feb 25 12:28:07 2015
--------------------------------------------------------------------------------

architecture a0 of FirePackets is

  signal u1_Fire  : std_logic;
  signal Pulse    : std_logic;
  signal O        : std_logic;
  signal U0_Pulse : std_logic;

  component Debounce
    generic(
      g_simulation : integer := 0);
    port (
      Clk   : in     std_logic;
      I     : in     std_logic;
      O     : out    std_logic;
      Pulse : out    std_logic;
      Rst   : in     std_logic);
  end component Debounce;

  component RepeatFire
    port (
      Clk       : in     std_logic;
      Enable    : in     std_logic;
      Fire      : out    std_logic;
      Rst       : in     std_logic;
      div_ratio : in     std_logic_vector(31 downto 0));
  end component RepeatFire;

  component OrGate
    port (
      A : in     std_logic;
      B : in     std_logic;
      O : out    std_logic);
  end component OrGate;

  component FirePacketGen
    port (
      Clk        : in     std_logic;
      Full       : in     std_logic;
      Rst        : in     std_logic;
      Tx_Fire    : in     std_logic;
      UDP_Tx     : out    dbus_type;
      WrReq      : out    std_logic;
      numpackets : in     std_logic_vector(9 downto 0);
      numwords   : in     std_logic_vector(13 downto 0));
  end component FirePacketGen;

begin
  --Just for testing a steady pace of packets:
  --200 Mbps = 200*1024*1024 = 209715200 bps 
  --packets: (9x60 + 62 + 64 + ... + 74) = 8128 bits/bunch of 16 packets
  --=> 200 Mbps ~ 16 packets @ 25.8 KHz
  --Ratio 62.5 MHz : 25.8 KHz = 2422

  u0: Debounce
    generic map(
      g_simulation => g_simulation)
    port map(
      Clk   => Clk,
      I     => Fire,
      O     => open,
      Pulse => U0_Pulse,
      Rst   => Rst);

  u1: RepeatFire
    port map(
      Clk       => Clk,
      Enable    => O,
      Fire      => u1_Fire,
      Rst       => Rst,
      div_ratio => x"00000976");

  u2: OrGate
    port map(
      A => u1_Fire,
      B => U0_Pulse,
      O => Pulse);

  u5: Debounce
    generic map(
      g_simulation => g_simulation)
    port map(
      Clk   => Clk,
      I     => udp_tstgen_cont,
      O     => O,
      Pulse => open,
      Rst   => Rst);

  u6: FirePacketGen
    port map(
      Clk        => Clk,
      Full       => UDP_Tx_Full,
      Rst        => Rst,
      Tx_Fire    => Pulse,
      UDP_Tx     => UDP_Tx,
      WrReq      => UDP_Tx_WrReq,
      numpackets => "0000010000",
      numwords   => "00000000001001");
end architecture a0 ; -- of FirePackets

--------------------------------------------------------------------------------
-- Object        : Entity design.sys_clk_pll
-- Last modified : Fri Nov 04 11:29:35 2016
--------------------------------------------------------------------------------



library ieee, unisim;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use unisim.VCOMPONENTS.all;

entity sys_clk_pll is
  port (
    clk_sys_o : out    std_logic;
    clkin_i   : in     std_logic);
end entity sys_clk_pll;

--------------------------------------------------------------------------------
-- Object        : Architecture design.sys_clk_pll.structure
-- Last modified : Fri Nov 04 11:29:35 2016
--------------------------------------------------------------------------------

architecture structure of sys_clk_pll is

  signal O        : std_ulogic;
  signal CLKFBOUT : std_ulogic := '0';
  signal CLKOUT0  : std_ulogic := '0';

begin

  u0: BUFG
    port map(
      O => O,
      I => clkin_i);

  cmp_clk_sys_buf: BUFG
    port map(
      O => clk_sys_o,
      I => CLKOUT0);

  cmp_sys_clk_pll: MMCME2_ADV
    generic map(
      BANDWIDTH            => "OPTIMIZED",
      CLKFBOUT_MULT_F      => 8.000,
      CLKFBOUT_PHASE       => 0.000,
      CLKFBOUT_USE_FINE_PS => FALSE,
      CLKIN1_PERIOD        => 8.00,
      CLKIN2_PERIOD        => 0.0,
      CLKOUT0_DIVIDE_F     => 16.000,
      CLKOUT0_DUTY_CYCLE   => 0.500,
      CLKOUT0_PHASE        => 0.000,
      CLKOUT0_USE_FINE_PS  => FALSE,
      CLKOUT1_DIVIDE       => 8,
      CLKOUT1_DUTY_CYCLE   => 0.500,
      CLKOUT1_PHASE        => 0.000,
      CLKOUT1_USE_FINE_PS  => FALSE,
      CLKOUT2_DIVIDE       => 1,
      CLKOUT2_DUTY_CYCLE   => 0.5,
      CLKOUT2_PHASE        => 0.0,
      CLKOUT2_USE_FINE_PS  => FALSE,
      CLKOUT3_DIVIDE       => 1,
      CLKOUT3_DUTY_CYCLE   => 0.5,
      CLKOUT3_PHASE        => 0.0,
      CLKOUT3_USE_FINE_PS  => FALSE,
      CLKOUT4_CASCADE      => FALSE,
      CLKOUT4_DIVIDE       => 1,
      CLKOUT4_DUTY_CYCLE   => 0.5,
      CLKOUT4_PHASE        => 0.0,
      CLKOUT4_USE_FINE_PS  => FALSE,
      CLKOUT5_DIVIDE       => 1,
      CLKOUT5_DUTY_CYCLE   => 0.5,
      CLKOUT5_PHASE        => 0.0,
      CLKOUT5_USE_FINE_PS  => FALSE,
      CLKOUT6_DIVIDE       => 1,
      CLKOUT6_DUTY_CYCLE   => 0.5,
      CLKOUT6_PHASE        => 0.0,
      CLKOUT6_USE_FINE_PS  => FALSE,
      COMPENSATION         => "ZHOLD",
      DIVCLK_DIVIDE        => 1,
      REF_JITTER1          => 0.010,
      REF_JITTER2          => 0.0,
      SS_EN                => "FALSE",
      SS_MODE              => "CENTER_HIGH",
      SS_MOD_PERIOD        => 10000,
      STARTUP_WAIT         => FALSE)
    port map(
      CLKFBOUT     => CLKFBOUT,
      CLKFBOUTB    => open,
      CLKFBSTOPPED => open,
      CLKINSTOPPED => open,
      CLKOUT0      => CLKOUT0,
      CLKOUT0B     => open,
      CLKOUT1      => open,
      CLKOUT1B     => open,
      CLKOUT2      => open,
      CLKOUT2B     => open,
      CLKOUT3      => open,
      CLKOUT3B     => open,
      CLKOUT4      => open,
      CLKOUT5      => open,
      CLKOUT6      => open,
      DO           => open,
      DRDY         => open,
      LOCKED       => open,
      PSDONE       => open,
      CLKFBIN      => CLKFBOUT,
      CLKIN1       => O,
      CLKIN2       => '0',
      CLKINSEL     => '1',
      DADDR        => (others => '0'),
      DCLK         => '0',
      DEN          => '0',
      DI           => (others => '0'),
      DWE          => '0',
      PSCLK        => '0',
      PSEN         => '0',
      PSINCDEC     => '0',
      PWRDWN       => '0',
      RST          => '0');
end architecture structure ; -- of sys_clk_pll

--------------------------------------------------------------------------------
-- Object        : Entity design.timing_ref_out
-- Last modified : Wed Feb 25 13:20:19 2015
--------------------------------------------------------------------------------



library ieee, unisim;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use unisim.VCOMPONENTS.all;

entity timing_ref_out is
  port (
    pps_i            : in     std_logic;
    pps_n_o          : out    std_logic;
    pps_p_o          : out    std_logic;
    ref_clk_62_5     : out    std_logic;
    ref_clk_i        : in     std_logic;
    ref_clk_locked_i : in     std_logic;
    refclk_n_o       : out    std_logic;
    refclk_p_o       : out    std_logic);
end entity timing_ref_out;

--------------------------------------------------------------------------------
-- Object        : Architecture design.timing_ref_out.structure
-- Last modified : Wed Feb 25 13:20:19 2015
--------------------------------------------------------------------------------


architecture structure of timing_ref_out is

  signal pps_oddr       : std_ulogic;
  signal pps_oddr_n     : std_ulogic;
  signal pps_i_n        : std_ulogic;
  signal ref_clk        : std_ulogic;

begin

   oddr_ref_clk: ODDR
   generic map(
      DDR_CLK_EDGE => "SAME_EDGE",
      INIT         => '0',
      SRTYPE       => "SYNC")
   port map(
      Q  => ref_clk,
      C  => ref_clk_i,
      CE => '1',
      D1 => '1',
      D2 => '0',
      R  => '0',
      S  => '0');

   obuf_ref_clk: OBUFDS
   generic map(
     CAPACITANCE => "DONT_CARE",
     IOSTANDARD  => "DEFAULT",
     SLEW        => "SLOW")
   port map(
     O  => refclk_p_o,
     OB => refclk_n_o,
     I  => ref_clk);
   
  -- Output buffering
  -------------------------------------
  ref_clk_62_5_buf : BUFG
  port map
   (O   => ref_clk_62_5,
    I   => ref_clk_i);

	 oddr_pps: ODDR
	   generic map(
		 DDR_CLK_EDGE => "SAME_EDGE",
		 INIT         => '0',
		 SRTYPE       => "SYNC")
	   port map(
		 Q  => pps_oddr,
		 C  => ref_clk_i,
		 CE => '1',
		 D1 => pps_i,
		 D2 => pps_i,
		 R  => '0',
		 S  => '0');

     obuf_pps: OBUFDS
	   generic map(
		 CAPACITANCE => "DONT_CARE",
		 IOSTANDARD  => "DEFAULT",
		 SLEW        => "SLOW")
	   port map(
		 O  => pps_p_o,
		 OB => pps_n_o,
		 I  => pps_oddr);

end architecture structure ; -- of timing_ref_out

--------------------------------------------------------------------------------
-- Object        : Entity design.RdOutAll
-- Last modified : Thu Feb 05 10:58:20 2015
--------------------------------------------------------------------------------



library ieee, work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.EMAC16bit_Package.all;

entity RdOutAll is
  port (
    Clk          : in     std_logic;
    ReadOut      : in     std_logic;
    Rst          : in     std_logic;
    UDP_Rx_Empty : in     std_logic_vector(NUM_UDP_PRTS-1 downto 0);
    UDP_Rx_RdReq : out    std_logic_vector(NUM_UDP_PRTS-1 downto 0));
end entity RdOutAll;

--------------------------------------------------------------------------------
-- Object        : Architecture design.RdOutAll.rtl
-- Last modified : Thu Feb 05 10:58:20 2015
--------------------------------------------------------------------------------


architecture rtl of RdOutAll is

begin
   Process (Clk, Rst)
   begin
      If Rst = '1' Then
         UDP_Rx_RdReq <= (others => '0');
	  ElsIf Rising_Edge(Clk) Then
	     If ReadOut = '1' Then
            For i In 0 to NUM_UDP_PRTS-1 loop
	           UDP_Rx_RdReq(i) <= not UDP_Rx_Empty(i);
	        end loop;
	     End If;
      End If;
   end Process;
end architecture rtl ; -- of RdOutAll

--------------------------------------------------------------------------------
-- Object        : Entity design.fpga
-- Last modified : Fri Nov 04 12:01:34 2016
--------------------------------------------------------------------------------



library ieee, work, unisim;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.EMAC16bit_Package.all;
use work.wr_fabric_pkg.all;
use unisim.VCOMPONENTS.all;
use work.wishbone_pkg.all;

entity fpga is
  generic(
    g_simulation            : integer := 0;
    g_lm32_wrpc_dpram_size  : integer := 131072/4;
    g_date_id               : integer := 0;
    g_revision_id           : integer := 0;
    g_lm32_wrpc_dpram_initf : string := "");
  port (
    ActLED              : out    std_logic_vector(3 downto 0);
    CPU_Gnt             : out    std_logic;
    CPU_Req             : out    std_logic;
    FPGA_PLL_REF_CLK0_N : in     std_logic;
    FPGA_PLL_REF_CLK0_P : in     std_logic;
    Fire                : in     std_logic;
    LED_ACT             : out    std_logic;
    LED_LINK            : out    std_logic;
    ONE_WIRE_BUS        : inout  std_logic;
    PLL25DAC1_SYNC_B    : out    std_logic;
    PLL25DAC2_SYNC_B    : out    std_logic;
    PLL25DAC_DIN        : out    std_logic;
    PLL25DAC_SCLK       : out    std_logic;
    PLL_OE_OUT_B        : out    std_logic;
    PLL_SCL             : inout  std_logic;
    PLL_SDA             : inout  std_logic;
    PPS_N               : out    std_logic;
    PPS_P               : out    std_logic;
    REF_CLK_N           : out    std_logic;
    REF_CLK_P           : out    std_logic;
    RESET               : in     std_logic;
    Readout             : in     std_logic;
    SFP_LOS             : in     std_logic;
    SFP_PRESENT         : in     std_logic;
    SFP_RATESEL         : inout  std_logic;
    SFP_RX_N            : in     std_logic;
    SFP_RX_P            : in     std_logic;
    SFP_SCL             : inout  std_logic;
    SFP_SDA             : inout  std_logic;
    SFP_TX_DISABLE      : out    std_logic;
    SFP_TX_FAULT        : in     std_logic;
    SFP_TX_N            : out    std_logic;
    SFP_TX_P            : out    std_logic;
    USBEXT_RX1          : in     std_logic;
    USBEXT_TX1          : out    std_logic;
    USB_RX1             : in     std_logic;
    USB_TX1             : out    std_logic;
    clk_20m_vcxo_i      : in     std_logic;
    dio_clk_n_i         : in     std_logic;
    dio_clk_p_i         : in     std_logic;
    dio_led_bot_o       : out    std_logic;
    dio_led_top_o       : out    std_logic;
    dio_n_i             : in     std_logic_vector(4 downto 0);
    dio_n_o             : out    std_logic_vector(4 downto 0);
    dio_oe_n_o          : out    std_logic_vector(4 downto 0);
    dio_onewire_b       : inout  std_logic;
    dio_p_i             : in     std_logic_vector(4 downto 0);
    dio_p_o             : out    std_logic_vector(4 downto 0);
    dio_sdn_ck_n_o      : out    std_logic;
    dio_sdn_n_o         : out    std_logic;
    dio_term_en_o       : out    std_logic_vector(4 downto 0);
    udp_tstgen_cont     : in     std_logic);
end entity fpga;

--------------------------------------------------------------------------------
-- Object        : Architecture design.fpga.structure
-- Last modified : Fri Nov 04 12:01:34 2016
--------------------------------------------------------------------------------

architecture structure of fpga is

  signal Empty              : std_logic_vector(NUM_UDP_PRTS-1 downto 0);
  signal RdReqo             : std_logic_vector(NUM_UDP_PRTS-1 downto 0);
  signal Rx                 : dbus_type_array(NUM_UDP_PRTS-1 downto 0);
  signal RdClk              : std_logic_vector(NUM_UDP_PRTS downto 0);
  signal Full               : std_logic_vector(NUM_UDP_PRTS-1 downto 0);
  signal WrReqo             : std_logic_vector(NUM_UDP_PRTS-1 downto 0);
  signal Tx                 : dbus_type_array(NUM_UDP_PRTS-1 downto 0);
  signal WrClk              : std_logic_vector(NUM_UDP_PRTS-1 downto 0);
  signal Emptyo             : std_logic_vector(NUM_UDP_PRTS-1 downto 0);
  signal Rst                : std_logic;
  signal clk20_vcxo_o       : std_logic;
  signal clk_gtx            : std_ulogic;
  signal ref_clk_62_5       : std_logic;
  signal Fullo              : std_logic_vector(NUM_UDP_PRTS-1 downto 0);
  signal WrReqi             : std_logic_vector(NUM_UDP_PRTS-1 downto 0);
  signal UDP_Tx             : dbus_type_array(NUM_UDP_PRTS-1 downto 0);
  signal UDP_Rx_RdReq       : std_logic_vector(NUM_UDP_PRTS-1 downto 0);
  signal clk_sys            : std_logic;
  signal Master_o           : t_wishbone_master_out;
  signal wb_ipmux_reg_o     : t_wishbone_slave_out;
  signal u11_Master_o       : t_wishbone_master_out;
  signal wb_ipmux_rx_tx_o   : t_wishbone_slave_out;
  signal dio_out            : std_logic_vector(4 downto 0);
  signal dio_in             : std_logic_vector(4 downto 0);
  signal PPS                : std_logic;
  signal O                  : std_ulogic;
  signal clk_ext_mul_locked : std_logic;
  signal clk_ext_mul        : std_logic;
  signal ref_clk            : std_logic;
  signal ref_clk_locked_o   : std_logic;
  signal uart_txd_o         : std_logic;
  signal Rx1                : std_logic;
  signal wrf_src_o          : t_wrf_source_out;
  signal snk_o              : t_wrf_sink_out;
  signal src_o              : t_wrf_source_out;
  signal wrf_snk_o          : t_wrf_sink_out;
  signal PauseVal           : std_logic_vector(15 downto 0);
  signal fc_pause_ack_o     : std_logic;
  signal wb_bridge_master_o : t_wishbone_master_out;
  signal wb_bridge_master_i : t_wishbone_slave_out;
  signal wb_bridge_slave_i  : t_wishbone_master_out;
  signal wb_bridge_slave_o  : t_wishbone_slave_out;

  component ipmux
    port (
      Empty            : out    std_logic_vector(NUM_UDP_PRTS-1 downto 0);
      Full             : out    std_logic_vector(NUM_UDP_PRTS-1 downto 0);
      PauseReq         : out    std_logic;
      PauseVal         : out    std_logic_vector(15 downto 0);
      RdClk            : in     std_logic_vector(NUM_UDP_PRTS downto 0);
      RdReq            : in     std_logic_vector(NUM_UDP_PRTS-1 downto 0);
      Rst              : in     std_logic;
      Rx               : out    dbus_type_array(NUM_UDP_PRTS-1 downto 0);
      Tx               : in     dbus_type_array(NUM_UDP_PRTS-1 downto 0);
      WrClk            : in     std_logic_vector(NUM_UDP_PRTS-1 downto 0);
      WrReq            : in     std_logic_vector(NUM_UDP_PRTS-1 downto 0);
      snk_i            : in     t_wrf_sink_in;
      snk_o            : out    t_wrf_sink_out;
      tx_clk           : in     std_logic;
      tx_reset         : in     std_logic;
      src_o            : out    t_wrf_source_out;
      src_i            : in     t_wrf_source_in;
      wb_ipmux_reg_i   : in     t_wishbone_slave_in;
      wb_ipmux_reg_o   : out    t_wishbone_slave_out;
      wb_ipmux_rx_tx_i : in     t_wishbone_slave_in;
      wb_ipmux_rx_tx_o : out    t_wishbone_slave_out;
      PauseAck         : in     std_logic;
      div_ratio        : out    std_logic_vector(31 downto 0);
      numwords         : out    std_logic_vector(13 downto 0);
      numpackets       : out    std_logic_vector(9 downto 0);
      udptstctrl       : out    std_logic_vector(2 downto 0);
      Stream           : out    natural range NUM_UDP_PRTS-1 downto 0;
      ConnectReq       : out    std_logic;
      CPU_Req          : out    std_logic;
      CPU_Gnt          : out    std_logic);
  end component ipmux;

  component ClkDist
    port (
      clk_sys_i    : in     std_logic;
      Emptyi       : in     std_logic_vector(NUM_UDP_PRTS-1 downto 0);
      Emptyo       : out    std_logic_vector(NUM_UDP_PRTS-1 downto 0);
      Fulli        : in     std_logic_vector(NUM_UDP_PRTS-1 downto 0);
      Fullo        : out    std_logic_vector(NUM_UDP_PRTS-1 downto 0);
      RdClk        : out    std_logic_vector(NUM_UDP_PRTS downto 0);
      RdReqi       : in     std_logic_vector(NUM_UDP_PRTS-1 downto 0);
      RdReqo       : out    std_logic_vector(NUM_UDP_PRTS-1 downto 0);
      Rx           : in     dbus_type_array(NUM_UDP_PRTS-1 downto 0);
      Tx           : out    dbus_type_array(NUM_UDP_PRTS-1 downto 0);
      UDP_Rx       : out    dbus_type_array(NUM_UDP_PRTS-1 downto 0);
      UDP_Tx       : in     dbus_type_array(NUM_UDP_PRTS-1 downto 0);
      WrClk        : out    std_logic_vector(NUM_UDP_PRTS-1 downto 0);
      WrReqi       : in     std_logic_vector(NUM_UDP_PRTS-1 downto 0);
      WrReqo       : out    std_logic_vector(NUM_UDP_PRTS-1 downto 0);
      ref_clk_62_5 : in     std_logic);
  end component ClkDist;

  component RdOutAll
    port (
      Clk          : in     std_logic;
      ReadOut      : in     std_logic;
      Rst          : in     std_logic;
      UDP_Rx_Empty : in     std_logic_vector(NUM_UDP_PRTS-1 downto 0);
      UDP_Rx_RdReq : out    std_logic_vector(NUM_UDP_PRTS-1 downto 0));
  end component RdOutAll;

  component ActivityLEDs
    port (
      ActLED  : out    std_logic_vector(3 downto 0);
      Clk     : in     std_logic;
      I       : in     std_logic_vector(3 downto 0);
      Rst     : in     std_logic;
      mnic_wr : in     std_logic);
  end component ActivityLEDs;

  component Debounce
    generic(
      g_simulation : integer := 0);
    port (
      Clk   : in     std_logic;
      I     : in     std_logic;
      O     : out    std_logic;
      Pulse : out    std_logic;
      Rst   : in     std_logic);
  end component Debounce;

  component timing_ref_out
    port (
      pps_i            : in     std_logic;
      pps_n_o          : out    std_logic;
      pps_p_o          : out    std_logic;
      ref_clk_62_5     : out    std_logic;
      ref_clk_i        : in     std_logic;
      ref_clk_locked_i : in     std_logic;
      refclk_n_o       : out    std_logic;
      refclk_p_o       : out    std_logic);
  end component timing_ref_out;

  component sys_clk_pll
    port (
      clk_sys_o : out    std_logic;
      clkin_i   : in     std_logic);
  end component sys_clk_pll;

  component FirePackets
    generic(
      g_simulation : integer := 0);
    port (
      Clk             : in     std_logic;
      Fire            : in     std_logic;
      Rst             : in     std_logic;
      UDP_Tx          : out    dbus_type;
      UDP_Tx_Full     : in     std_logic;
      UDP_Tx_WrReq    : out    std_logic;
      udp_tstgen_cont : in     std_logic);
  end component FirePackets;

  component MetaStabilizer
    generic(
      g_simulation : integer := 0);
    port (
      Clk   : in     std_logic;
      RESET : in     std_logic;
      O     : out    std_logic;
      O_n   : out    std_logic;
      EOS   : in     std_logic);
  end component MetaStabilizer;

  component DummyTx
    port (
      UDP_Tx : out    dbus_type_array(NUM_UDP_PRTS-2 downto 0);
      WrReqi : out    std_logic_vector(NUM_UDP_PRTS-2 downto 0));
  end component DummyTx;

  component wb_DummySlave
    port (
      Slave_i : in     t_wishbone_slave_in;
      Slave_o : out    t_wishbone_slave_out);
  end component wb_DummySlave;

  component wb_DummyMaster
    port (
      Master_i : in     t_wishbone_master_in;
      Master_o : out    t_wishbone_master_out);
  end component wb_DummyMaster;

  component USB_FanOut
    port (
      Rx1        : out    std_logic;
      Rx2        : out    std_logic;
      Tx1        : in     std_logic;
      Tx2        : in     std_logic;
      USBEXT_RX1 : in     std_logic;
      USBEXT_RX2 : in     std_logic;
      USBEXT_TX1 : out    std_logic;
      USBEXT_TX2 : out    std_logic;
      USB_RX1    : in     std_logic;
      USB_RX2    : in     std_logic;
      USB_TX1    : out    std_logic;
      USB_TX2    : out    std_logic);
  end component USB_FanOut;

  component ext_pll_10_to_62_5m
    port (
      clk_ext_i     : in     std_logic;
      clk_ext_mul_o : out    std_logic;
      rst_a_i       : in     std_logic;
      locked_o      : out    std_logic);
  end component ext_pll_10_to_62_5m;

  component clb_wrpc
    generic(
      g_simulation  : integer := 0;
      g_dpram_size  : integer := 90112/4;
      g_dpram_initf : string := "");
    port (
      LED_ACT              : out    std_logic;
      LED_LINK             : out    std_logic;
      bitslide             : out    std_logic_vector(4 downto 0);
      button1_i            : in     std_logic;
      button2_i            : in     std_logic;
      clk20_vcxo           : in     std_logic;
      clk_ext_i            : in     std_logic := '0';
      clk_ext_mul_i        : in     std_logic := '0';
      clk_ext_mul_locked_i : in     std_logic := '1';
      clk_gtx_i            : in     std_logic;
      clk_sys_i            : in     std_logic;
      dac_cs1_n_o          : out    std_logic;
      dac_cs2_n_o          : out    std_logic;
      dac_din_o            : out    std_logic;
      dac_sclk_o           : out    std_logic;
      dio_led_bot_o        : out    std_logic;
      dio_led_top_o        : out    std_logic;
      dio_onewire_b        : inout  std_logic;
      fc_pause_ack_o       : out    std_logic;
      fc_pause_delay_i     : in     std_logic_vector(15 downto 0);
      fc_pause_p_i         : in     std_logic;
      fpga_scl_b           : inout  std_logic;
      fpga_sda_b           : inout  std_logic;
      pps_ext_i            : in     std_logic := '0';
      pps_o                : out    std_logic;
      ref_clk_locked_o     : out    std_logic;
      ref_clk_o            : out    std_logic;
      rx_rbclk_o           : out    std_logic;
      rxts_o               : out    std_logic;
      sfp_los_i            : in     std_logic;
      sfp_mod_def0_b       : in     std_logic;
      sfp_mod_def1_b       : inout  std_logic;
      sfp_mod_def2_b       : inout  std_logic;
      sfp_rate_select_b    : inout  std_logic;
      sfp_rxn_i            : in     std_logic;
      sfp_rxp_i            : in     std_logic;
      sfp_tx_disable_o     : out    std_logic;
      sfp_tx_fault_i       : in     std_logic;
      sfp_txn_o            : out    std_logic;
      sfp_txp_o            : out    std_logic;
      thermo_id            : inout  std_logic;
      tm_cycles_o          : out    std_logic_vector(27 downto 0);
      tm_tai_o             : out    std_logic_vector(39 downto 0);
      tm_time_valid_o      : out    std_logic;
      txts_o               : out    std_logic;
      uart_rxd_i           : in     std_logic;
      uart_txd_o           : out    std_logic;
      wb_bridge_master_i   : in     t_wishbone_master_in;
      wb_bridge_master_o   : out    t_wishbone_master_out;
      wb_bridge_slave_i    : in     t_wishbone_slave_in;
      wb_bridge_slave_o    : out    t_wishbone_slave_out;
      wrf_snk_i            : in     t_wrf_sink_in := c_dummy_snk_in;
      wrf_snk_o            : out    t_wrf_sink_out;
      wrf_src_i            : in     t_wrf_source_in := c_dummy_src_in;
      wrf_src_o            : out    t_wrf_source_out);
  end component clb_wrpc;

begin
  --125 MHz
  --62.5 MHz
  --BitSlide and Trig can be connected to GPIO_LEDs 
  --for debugging purposes
  --Note that pps_o, txts_o and rxts_o originate from the
  --refclk that was output by the tx_out_clk of the PHY that
  --originates from clk_gtx_i and thus is phase locked with
  --the 62.5 MHz RefClk
  --62.5 MHz
  --rx_rbclk is the serial link recovered clock
  --All timing signals are in
  --the ref_clk_o domain.
  --ref_clk is the actual phase
  --compensated clock
  --tm_time_valid is just a bit
  --in a wishbone register?
  --The Rst signal is held asserted after
  --configuration and Clk is running.
  --This happens when a counter expires.
  --This relies on the fact that Xilinx
  --flip-flops have an initial value '0'
  --after configuration.
  --Debug:
  PLL_OE_OUT_B <= '0';
  dio_out(0) <= PPS;

  gen_dio_iobufs: for i in 0 to 4 generate
  begin

      U_ibuf: IBUFDS
        generic map(
          CAPACITANCE      => "DONT_CARE",
          DIFF_TERM        => TRUE,
          IBUF_DELAY_VALUE => "0",
          IBUF_LOW_PWR     => TRUE,
          IFD_DELAY_VALUE  => "AUTO",
          IOSTANDARD       => "DEFAULT",
          DQS_BIAS         => "FALSE")
        port map(
          O  => dio_in(i),
          I  => dio_p_i(i),
          IB => dio_n_i(i));

      U_obufds: OBUFDS
        generic map(
          CAPACITANCE => "DONT_CARE",
          IOSTANDARD  => "DEFAULT",
          SLEW        => "SLOW")
        port map(
          O  => dio_p_o(i),
          OB => dio_n_o(i),
          I  => dio_out(i));
  end generate gen_dio_iobufs;

  u1: IBUFDS_GTE2
    generic map(
      CLKCM_CFG    => TRUE,
      CLKRCV_TRST  => TRUE,
      CLKSWING_CFG => "11")
    port map(
      O     => clk_gtx,
      ODIV2 => open,
      CEB   => '0',
      I     => FPGA_PLL_REF_CLK0_P,
      IB    => FPGA_PLL_REF_CLK0_N);

  u5: ipmux
    port map(
      Empty            => Empty,
      Full             => Full,
      PauseReq         => open,
      PauseVal         => PauseVal,
      RdClk            => RdClk,
      RdReq            => RdReqo,
      Rst              => Rst,
      Rx               => Rx,
      Tx               => Tx,
      WrClk            => WrClk,
      WrReq            => WrReqo,
      snk_i            => wrf_src_o,
      snk_o            => snk_o,
      tx_clk           => clk_sys,
      tx_reset         => Rst,
      src_o            => src_o,
      src_i            => wrf_snk_o,
      wb_ipmux_reg_i   => Master_o,
      wb_ipmux_reg_o   => wb_ipmux_reg_o,
      wb_ipmux_rx_tx_i => u11_Master_o,
      wb_ipmux_rx_tx_o => wb_ipmux_rx_tx_o,
      PauseAck         => fc_pause_ack_o,
      div_ratio        => open,
      numwords         => open,
      numpackets       => open,
      udptstctrl       => open,
      Stream           => open,
      ConnectReq       => open,
      CPU_Req          => CPU_Req,
      CPU_Gnt          => CPU_Gnt);

  u6: ClkDist
    port map(
      clk_sys_i    => clk_sys,
      Emptyi       => Empty,
      Emptyo       => Emptyo,
      Fulli        => Full,
      Fullo        => Fullo,
      RdClk        => RdClk,
      RdReqi       => UDP_Rx_RdReq,
      RdReqo       => RdReqo,
      Rx           => Rx,
      Tx           => Tx,
      UDP_Rx       => open,
      UDP_Tx       => UDP_Tx,
      WrClk        => WrClk,
      WrReqi       => WrReqi,
      WrReqo       => WrReqo,
      ref_clk_62_5 => ref_clk_62_5);

  u7: RdOutAll
    port map(
      Clk          => clk_sys,
      ReadOut      => '1',
      Rst          => Rst,
      UDP_Rx_Empty => Emptyo,
      UDP_Rx_RdReq => UDP_Rx_RdReq);

  u10: ActivityLEDs
    port map(
      ActLED  => ActLED,
      Clk     => clk_sys,
      I       => Emptyo,
      Rst     => Rst,
      mnic_wr => '1');

  u9: Debounce
    generic map(
      g_simulation => g_simulation)
    port map(
      Clk   => clk_sys,
      I     => '1',
      O     => open,
      Pulse => open,
      Rst   => Rst);

  u17: timing_ref_out
    port map(
      pps_i            => PPS,
      pps_n_o          => PPS_N,
      pps_p_o          => PPS_P,
      ref_clk_62_5     => ref_clk_62_5,
      ref_clk_i        => ref_clk,
      ref_clk_locked_i => ref_clk_locked_o,
      refclk_n_o       => REF_CLK_N,
      refclk_p_o       => REF_CLK_P);

  u3: sys_clk_pll
    port map(
      clk_sys_o => clk_sys,
      clkin_i   => clk_gtx);

  u14: FirePackets
    generic map(
      g_simulation => g_simulation)
    port map(
      Clk             => clk_sys,
      Fire            => Fire,
      Rst             => Rst,
      UDP_Tx          => UDP_Tx(NUM_UDP_PRTS-1),
      UDP_Tx_Full     => Fullo(NUM_UDP_PRTS-1),
      UDP_Tx_WrReq    => WrReqi(NUM_UDP_PRTS-1),
      udp_tstgen_cont => udp_tstgen_cont);

  u12: MetaStabilizer
    generic map(
      g_simulation => g_simulation)
    port map(
      Clk   => clk_sys,
      RESET => RESET,
      O     => Rst,
      O_n   => open,
      EOS   => '1');

  u8: DummyTx
    port map(
      UDP_Tx => UDP_Tx(NUM_UDP_PRTS-2 downto 0),
      WrReqi => WrReqi(NUM_UDP_PRTS-2 downto 0));

  u4: wb_DummySlave
    port map(
      Slave_i => wb_bridge_master_o,
      Slave_o => wb_bridge_master_i);

  cmp_clk_vcxo: BUFG
    port map(
      O => clk20_vcxo_o,
      I => clk_20m_vcxo_i);

  u0a: wb_DummyMaster
    port map(
      Master_i => wb_bridge_slave_o,
      Master_o => wb_bridge_slave_i);

  u2: wb_DummyMaster
    port map(
      Master_i => wb_ipmux_reg_o,
      Master_o => Master_o);

  u11: wb_DummyMaster
    port map(
      Master_i => wb_ipmux_rx_tx_o,
      Master_o => u11_Master_o);

  u13: USB_FanOut
    port map(
      Rx1        => Rx1,
      Rx2        => open,
      Tx1        => uart_txd_o,
      Tx2        => '1',
      USBEXT_RX1 => USBEXT_RX1,
      USBEXT_RX2 => '1',
      USBEXT_TX1 => USBEXT_TX1,
      USBEXT_TX2 => open,
      USB_RX1    => USB_RX1,
      USB_RX2    => '1',
      USB_TX1    => USB_TX1,
      USB_TX2    => open);

  U_input_buffer: IBUFGDS
    generic map(
      CAPACITANCE      => "DONT_CARE",
      DIFF_TERM        => TRUE,
      IBUF_DELAY_VALUE => "0",
      IBUF_LOW_PWR     => TRUE,
      IOSTANDARD       => "DEFAULT")
    port map(
      O  => O,
      I  => dio_clk_p_i,
      IB => dio_clk_n_i);

  U_Ext_PLL: ext_pll_10_to_62_5m
    port map(
      clk_ext_i     => O,
      clk_ext_mul_o => clk_ext_mul,
      rst_a_i       => Rst,
      locked_o      => clk_ext_mul_locked);

  u0: clb_wrpc
    generic map(
      g_simulation  => g_simulation,
      g_dpram_size  => g_lm32_wrpc_dpram_size,
      g_dpram_initf => g_lm32_wrpc_dpram_initf)
    port map(
      LED_ACT              => LED_ACT,
      LED_LINK             => LED_LINK,
      bitslide             => open,
      button1_i            => Rst,
      button2_i            => '0',
      clk20_vcxo           => clk20_vcxo_o,
      clk_ext_i            => O,
      clk_ext_mul_i        => clk_ext_mul,
      clk_ext_mul_locked_i => clk_ext_mul_locked,
      clk_gtx_i            => clk_gtx,
      clk_sys_i            => clk_sys,
      dac_cs1_n_o          => PLL25DAC1_SYNC_B,
      dac_cs2_n_o          => PLL25DAC2_SYNC_B,
      dac_din_o            => PLL25DAC_DIN,
      dac_sclk_o           => PLL25DAC_SCLK,
      dio_led_bot_o        => dio_led_bot_o,
      dio_led_top_o        => dio_led_top_o,
      dio_onewire_b        => dio_onewire_b,
      fc_pause_ack_o       => fc_pause_ack_o,
      fc_pause_delay_i     => PauseVal,
      fc_pause_p_i         => '0',
      fpga_scl_b           => PLL_SCL,
      fpga_sda_b           => PLL_SDA,
      pps_ext_i            => dio_in(3),
      pps_o                => PPS,
      ref_clk_locked_o     => ref_clk_locked_o,
      ref_clk_o            => ref_clk,
      rx_rbclk_o           => open,
      rxts_o               => dio_out(1),
      sfp_los_i            => SFP_LOS,
      sfp_mod_def0_b       => SFP_PRESENT,
      sfp_mod_def1_b       => SFP_SCL,
      sfp_mod_def2_b       => SFP_SDA,
      sfp_rate_select_b    => SFP_RATESEL,
      sfp_rxn_i            => SFP_RX_N,
      sfp_rxp_i            => SFP_RX_P,
      sfp_tx_disable_o     => SFP_TX_DISABLE,
      sfp_tx_fault_i       => SFP_TX_FAULT,
      sfp_txn_o            => SFP_TX_N,
      sfp_txp_o            => SFP_TX_P,
      thermo_id            => ONE_WIRE_BUS,
      tm_cycles_o          => open,
      tm_tai_o             => open,
      tm_time_valid_o      => open,
      txts_o               => dio_out(2),
      uart_rxd_i           => Rx1,
      uart_txd_o           => uart_txd_o,
      wb_bridge_master_i   => wb_bridge_master_i,
      wb_bridge_master_o   => wb_bridge_master_o,
      wb_bridge_slave_i    => wb_bridge_slave_i,
      wb_bridge_slave_o    => wb_bridge_slave_o,
      wrf_snk_i            => src_o,
      wrf_snk_o            => wrf_snk_o,
      wrf_src_i            => snk_o,
      wrf_src_o            => wrf_src_o);
    dio_oe_n_o(0)          <= '0';
    dio_oe_n_o(2 downto 1) <= (others => '0');
    dio_oe_n_o(3)          <= '1';        -- for external 1-PPS
    dio_oe_n_o(4)          <= '1';        -- for external 10MHz clock

    dio_term_en_o <= (others => '0');

    dio_sdn_ck_n_o <= '1';
    dio_sdn_n_o    <= '1';
end architecture structure ; -- of fpga

